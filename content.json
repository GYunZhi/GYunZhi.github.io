[{"title":"Express框架入门","date":"2018-12-08T20:16:56.000Z","path":"2018/12/09/Express框架入门/","text":"Express 简介Express 是一基于Node的一个框架，用来快速创建Web服务的一个工具，为什么要使用Express呢，因为创建Web服务如果从Node开始有很多繁琐的工作要做，而Express为你解放了很多工作，从而让你更加关注于逻辑业务开发。举个例子： 创建一个很简单的网站： 使用Node来开发： 12345678var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('Hello World')&#125;).listen(3000) 这是一个简单的 Hello World，但实际上真正的网站要比这个复杂很多，主要有： （1） 多个页面的路由功能 （2） 对请求的逻辑处理 那么使用node原生写法就要进行以下处理 1234567891011121314151617181920212223242526272829303132var http = require('http')var url = require('url')var app = http.createServer(function (req, rep) &#123; //req.url: 访问路径 var urlObj = url.parse(req.url); switch (urlObj.pathname) &#123; case '/': //首页 rep.writeHead(200, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) rep.end('&lt;h1&gt;这是首页&lt;/h1&gt;'); break; case '/user': //个人中心 rep.writeHead(200, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) rep.end('&lt;h1&gt;这是个人中心&lt;/h1&gt;'); break; default: //处理其他情况 rep.writeHead(404, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) rep.end('&lt;h1&gt;页面不见了&lt;/h1&gt;'); break; &#125;&#125;)app.listen(3000, 'localhost') 代码里在createServer函数里传递一个回调函数用来处理http请求并返回结果，在这个函数里有两个工作要做： （1）路由分析，对于不同的路径需要进行分别处理 （2）逻辑处理和返回，对某个路径进行特别的逻辑处理 如果一个大型网站拥有海量的页面，每个页面的处理逻辑也是交错复杂，那这里的写法会非常混乱，没法维护，为了解决这个问题，TJ提出了Connect的概念，把Java里面的中间件概念第一次进入到JS的世界，Web请求将一个一个经过中间件，并通过其中一个中间件返回，大大提高了代码的可维护性和开发效率。 1234567891011121314// 引入connect模块var connect = require(\"connect\");var http = require(\"http\"); // 建立appvar app = connect(); // 添加中间件app.use(function(request, response) &#123; response.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); response.end(\"Hello world!\");&#125;);启动应用 http.createServer(app).listen(3000); 但是TJ认为还应该更好一点，于是Express诞生了，通过Express开发以上的例子： 使用Express来开发： 12345678910111213141516var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);app.get('/about', function (req, res) &#123; res.send('About');&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port); &#125;); 从Express例子可以看出，使用Express大大减少了代码，而且逻辑更为简洁，所以使用Express可以提高开发效率并降低项目维护成本。 Express 安装使用1.手动安装 12npm init npm install express || yarn add express 123456789101112var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2.通过express-generator生成express项目 1234567npm install express-generator -gexpress --ejs express_demo || . // .代表在当前目录生成项目cd express_demonpm install || yarn#运行项目npm start || node ./bin/www Express 源码结构在 Express4.x 的版本中，已经移除了connect模块，Express内部自己实现了connect的模块，并进行了一些增强处理。这里对Express 源码进行一些简单的说明。 首先我们看一下Express的源码结构： 12345678910111213141516171819202122232425middleware: 中间件 init.js 初始化request，response query.js 格式化url，将url中的rquest参数剥离, 储存到req.query中router: 路由 index.js Router类，用于存储中间件数组 layer.js 中间件实体类 route.js Route类，用于处理不同Methodapplication.js 对外APIexpress.js 入口request.js 请求增强response.js 返回增强utils.js 工具函数view.js 模版相关 Express中的中间件和connect中不太一样，因为Express有两种中间件，普通中间件、路由中间件。 app初始化时，会push两个中间件（init，query）进router.stack里。我们可以通过app.use往app添加非路由中间件，也可以通过app[METHOD]添加路由中间件。 普通中间件： 使用app.use方法的时候，会通过lazyrouter()方法实例化一个Router对象，在整个app中只有一个Router对象。最终调用router.use()方法，把 Layer 添加到 Router stack 中，且这个 Layer 的 route属性为undefined。 路由中间件： 使用app[METHOD]方法的时候，同样会把这个中间件添加到 Router对象的 stack 中， 但是这个 Layer 的 route属性会指向一个实例化的 Route 对象， 在Route里也有一个实例化的 Layer，且放在stack里，与Router的 Layer不同的是，Route的没有layer.route 且 layer.method 存放了http方法。 总结： express 中添加中间件方法有 app.use 和 app[METHOD] ,当然还有内置的 Router 类，app.use 用来添加非路由中间件，app[METHOD] 用来添加路由中间件。 Layer 类封装中间的 path 和 handle (处理函数) Router 和 Route都有对应的 stack，但是 Route 在整个 app 中只有一个，而 Route 可以有多个。放在Router stack 里的路由中间件，通过Layer.route 指向 Route，与 Route stack 相关联起来。 Express 运行原理 Express基本使用示例代码： https://gitee.com/gongyz/blog_express/tree/study/ 路由路由定义了应用程序如何响应客户端的请求，这些请求是由一个 URI + HTTP请求方法 组成，每个路由都可以指定一个或者多个处理函数，处理函数会在匹配路由时执行。 路由的定义采用以下的结构：app.METHOD(PATH, HANDLER) 1、基本使用1234567891011121314151617181920212223242526272829303132333435363738// 默认路由，基础路径为 '/'app.get('/', function (req,rep,next) &#123; rep.send('Hello World!')&#125;)app.get('/user', function (req,rep,next) &#123; rep.send('user')&#125;)// 也可以指定多个处理函数app.get('/user',fn1, fn2, ... function (req,rep,next) &#123; rep.send('user')&#125;)app.get('/user/:name/:group', function (req,rep,next) &#123; console.log(rep.params) next()&#125;)// 创建子路由，并且对子路由进行配置var router = express.Router(&#123; mergeParams: true, caseSensitive: true, strict: true&#125;);// 注册子路由，基础路径为 /user/:name/:groupapp.use('/user/:name/:group', router)// /user:name:group 和 /user:name:group/ 都可以匹配router.get('/', function (req, rep, next) &#123; rep.send(req.params)&#125;)// /user:name:group/testrouter.get('/test', function (req, rep, next) &#123; rep.send('router test')&#125;) 2、路由路径路由路径可以是字符串、字符串匹配模式或正则表达式，详细的可以查看官方文档关于路由 这一节。 123456789101112/users/:userId/books/:bookId/abc?d 0次或1次/abc+d 1次或多次/abc\\*d c~d之间任意字符/a(bc)?d/a(bc)+d/\\/ab[1,2]\\/cd/ 正则匹配[/abc?d, /a(bc)?d] // 多个匹配app.get(/\\/ab[1,2]\\/cd/,function (req,res,next) &#123; res.send('finish')&#125;) 3、app.all()123456// router.all() 所有匹配到该路由路径的HTTP方法都会执行处理函数router.all(function(req, res, next) &#123; // runs for all HTTP verbs first // think of it as route specific middleware! next();&#125;) 4、app.param()1234567891011121314151617181920212223242526272829303132333435363738394041424344// 普通写法对请求参数进行处理 app.get('/user/:id', function (req, res, next) &#123; if (req.params.id !== '1') &#123; res.send(404) &#125; else &#123; res.send('success') &#125; &#125;)// 使用app.param添加一个拦截器，对请求参数进行处理，下面的路由用来处理正确的请求app.param('id', function (req, res, next, id) &#123; if (req.params.id !== '1') &#123; res.send(404) &#125; else &#123; next() &#125;&#125;)app.get('/user/:id', function (req, res, next) &#123; res.send('success')&#125;)// 多个参数时的写法// 回调函数会执行两次，等同于下面的写法，建议采用下面的写法分开写app.param(['id', 'name'], function (req, res, next, value) &#123; console.log(value) next()&#125;)// 第一次app.param('id', function (req, res, next, id) &#123; console.log(id) next()&#125;)// 第二次app.param('name', function (req, res, next, name) &#123; console.log(name) next()&#125;)app.get('/user/:id/:name', function (req, res, next) &#123; res.send('success')&#125;)// router.param 用法和 app.param一样，不同的是router.param不支持['id', 'name']接收参数 5、app.route()12345678910111213141516171819202122// 使用 router.route() 方法避免对同一个路径重复命名router.route('/users/:user_id').all(function(req, res, next) &#123; // runs for all HTTP verbs first // think of it as route specific middleware! next();&#125;).get(function(req, res, next) &#123; res.json(req.user);&#125;).post(function(req, res, next) &#123; next(new Error('not implemented'));&#125;).put(function(req, res, next) &#123; // just an example of maybe updating the user req.user.name = req.params.name; // save user ... etc res.json(req.user);&#125;).delete(function(req, res, next) &#123; next(new Error('not implemented'));&#125;); 静态资源访问express内部引用了 serve-static 这个库，并且挂载到了express的static方法上。在后面的响应部分也介绍了在不使用 express.static 方法情况下如何实现静态资源访问。 123456789// 基本用法app.use(express.static(path.join(__dirname, 'public')));// 自定义配置app.use(express.static('public', &#123; index: 'index.html', // ['index.html', 'index.htm'] 指定默认的首页 dotfiles: 'allow', // 是否.XXX extensions:['html', 'htm'] // 配置扩展名&#125;)) 获取客户端请求数据1、获取URL中的数据12345678910111213app.get('/index/:id', function (req,res,next) &#123; res.send(` &lt;ul&gt; &lt;li&gt;req.methed = $&#123;req.method&#125;&lt;/li&gt; &lt;li&gt;req.hostnam = $&#123;req.hostname&#125;&lt;/li&gt; &lt;li&gt;req.originalUrl = $&#123;req.originalUrl&#125;&lt;/li&gt; &lt;li&gt;req.path = $&#123;req.path&#125;&lt;/li&gt; &lt;li&gt;req.protocol = $&#123;req.protocol&#125;&lt;/li&gt; &lt;li&gt;req.query = $&#123;JSON.stringify(req.query)&#125;&lt;/li&gt; &lt;li&gt;req.params= $&#123;JSON.stringify(req.params)&#125;&lt;/li&gt; &lt;/ul&gt; `)&#125;) 2、获取 headers 中的数据123app.get('/index', function (req,res) &#123; res.send(req.headers)&#125;) 3、获取 body 中的数据123456789101112131415161718192021表单提交编码方式常用的有三种application/x-www-form-urlencoded 默认text/plainmultipart/form-data // 该类型需要使用 Multer 中间件处理，下面会介绍// 引入 body-parse 模块，express支持 json、urlencoded、text 方法// express内部已经引入了 body-parse 模块，并且把两个常用的方法json、urlencoded方法挂载到了express实例上// 处理 Content-Type 为 application/x-www-form-urlencoded 类型的请求app.use(bodyParser.urlencoded());// 处理 Content-Type 为 text/plain 类型的请求app.use(bodyParser.text());// 处理 Content-Type 为 application/json 类型的请求app.use(bodyParser.json()); // 使用 Postman测试app.post('/test', function (req,res) &#123; res.send(req.body)&#125;) 4、获取上传文件的数据这里需要用到 Multer 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。 注意: Multer 不会处理任何非 multipart/form-data 类型的表单数据。 安装 1$ npm install --save multer 使用 Multer 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。 body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。 警告: 确保你总是处理了用户的文件上传。永远不要将 multer 作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用。 基本使用方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* Multer 接受一个 options 对象，其中最基本的是 dest 属性， 这将告诉 Multer 将上传文件保存在哪。如果你省略 options对象， 这些文件将保存在内存中，永远不会写入磁盘。*/// var upload = multer(&#123; dest: 'uploads/' &#125;)// 内存存储// var storage = multer.memoryStorage()// 磁盘存储var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, 'uploads') &#125;, filename: function (req, file, cb) &#123; cb(null, file.originalname + '-' + Date.now()) &#125;&#125;)// 创建上传中间件对请求进行拦截，处理上传的文件// 设置一个函数来控制什么文件可以上传以及什么文件应该跳过function fileFilter (req, file, cb) &#123; // 这个函数应该调用 cb 用 boolean 值来指示是否应接受该文件 if (file.mimetype === 'image/png') &#123; // 接受这个文件，使用`true` cb(null, true) &#125; else &#123; // 拒绝这个文件，使用false cb(null, false) // 拒绝同时抛出错误给express处理 cb(new Error('file type illegal'),false) &#125;&#125;var upload = multer(&#123; storage: storage, fileFilter: fileFilter &#125;)// 只接受文本域app.post('/upload', upload.none(), function (req,res) &#123; res.send(req.body)&#125;)// 接受文本域和一切上传的文件，文件数组将保存在 req.filesapp.post('/upload', upload.any(), function (req,res) &#123; console.log('req.body', req.body) console.log('req.file', req.file) console.log('req.files', req.files) res.send('请求成功')&#125;)// 处理单个以 fieldname 命名的文件，fieldname 由表单指定, 文件的信息保存在 req.fileapp.post('/upload', upload.single('file'), function (req,res) &#123; console.log('req.body', req.body) console.log('req.file', req.file) console.log('req.files', req.files) res.send('请求成功')&#125;)// 处理多个以 fieldname 命名的文件，文件 fieldname 相同, 可以配置 maxCount 来限制上传的最大数量，文件的信息保存在 req.filesapp.post('/upload', upload.array('file', 3), function (req,res) &#123; console.log('req.body', req.body) console.log('req.file', req.file) console.log('req.files', req.files) res.send('请求成功')&#125;)// 处理不同 fieldname 命名的文件，文件的信息保存在 req.filesfields 应该是一个对象数组，具有 name 和可选的 maxCount 属性 let fields = [ &#123; name: 'file', maxCount: 1 &#125;, &#123; name: 'file2', maxCount: 2 &#125; ] app.post('/upload', upload.fields(fields), function (req,res) &#123; console.log('req.body', req.body) console.log('req.file', req.file) console.log('req.files', req.files) res.send('请求成功')&#125;) 响应1、基本方式的响应123456789101112131415161718192021222324252627282930313233343536373839app.get('/txt',function (req,res) &#123; res.send('my name is gongyz');&#125;)app.get('/json',function (req,res) &#123; res.send(&#123;name: 'gongyz', age: 23&#125;);&#125;)app.get('/html', function(req,res) &#123; res.send('&lt;p style=\"color: red\"&gt;Hello World&lt;/p&gt;')&#125;) app.get('/download',function (req,res) &#123; res.download('public/download.txt'); &#125;)app.get('/redirect',function (req,res) &#123; res.redirect('http://www.baidu.com')&#125;)// 静态资源访问app.get('/file/:name', function (req, res, next) &#123; var options = &#123; root: __dirname + '/public/', dotfiles: 'deny', headers: &#123; 'x-timestamp': Date.now(), 'x-sent': true &#125; &#125; var fileName = req.params.name; res.sendFile(fileName, options, function (err) &#123; if (err) &#123; next(err) &#125; else &#123; console.log('Sent:', fileName) &#125; &#125;)&#125;) 2、动态页面渲染12345678910111213141516171819202122232425262728// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');app.use('/' ,indexRouter)app.use('/user' ,usersRouter)/* GET home page. */// router.get('/', function(req, res, next) &#123;// var arr =[1,2,3,4,5,6,7,8]// res.render('index', &#123; title: 'index', arr &#125;);// &#125;);// 实际项目中的做法var db = &#123; getData (req,res,next) &#123; var arr =[1,2,3,4,5,6,7,8] res.locals = &#123;title: 'index', arr&#125; next() &#125;&#125;router.get('/',db.getData, function(req, res, next) &#123; res.render('index');&#125;);","tags":[{"name":"Express","slug":"Express","permalink":"https://gyunzhi.github.io/tags/Express/"}]},{"title":"Connect框架源码分析","date":"2018-11-10T19:26:32.000Z","path":"2018/11/11/Connect框架源码分析/","text":"Connect 是一个可扩展(中间件作为插件)的 Http 服务器框架，Connect 刚出道之时自带了许多中间件，为保证其框架的轻量级以及扩展性，最终还是将这些中间件的实现抛给了社区。可能在搜索 Connect 的相关项目时，你会发现 connect().use(connect.bodyParser())这些的写法，这对于现在的 Connect (最新版本3.6.0) 是不支持的，而只能通过 npm 下载第三方的模块 (如 body-parser) 替代原先的中间价。 基本使用123456789101112131415161718192021222324252627282930const connect = require('connect');var createError = require('http-errors');var http = require('http');var app = connect()app.use('/', function(req, res, next) &#123; res.writeHead(200,'OK',&#123; //'content-type': 'text/plain' //纯文本 'content-type': 'text/html;charset=utf-8' &#125;) res.write('&lt;h1&gt;你好，欢迎学习connect&lt;/h1&gt;') res.end()&#125;)// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; res.statusCode = 404; res.end('Not Found');&#125;);// 两种方式监听指定端口app.listen(3000) // 这种方式在connect里面调用了http.createServer方法// http.createServer(app).listen(3000); 源码分析这篇文章是基于&quot;version&quot;: &quot;3.6.6&quot;这个版本来对源码进行分析的，这个版本所有的代码都在index.js文件中。下面我们来看一下connect是怎么工作的。 首先我们看一下这个文件的模块出口，可以看到导出了一个createServer函数，这个函数最终返回的是app，app本身是一个函数，在下面一段代码中我们可以的看到它是作为了request事件的处理函数。同时它既继承了proto、EventEmitter属性和方法，也有自己的route、stack属性。 12345678910111213141516171819202122232425// 模块出口module.exports = createServer;// 判断当前环境，初始化proto 对象var env = process.env.NODE_ENV || 'development';var proto = &#123;&#125;;function createServer() &#123; // app 函数对象，可以添加属性和方法 function app(req, res, next)&#123; app.handle(req, res, next); &#125; // merge： 相当于Object.assign merge(app, proto); // 继承proto的属性和方法 merge(app, EventEmitter.prototype); // 继承EventEmitter（事件派发器）属性和方法 app.route = '/'; app.stack = []; // 存放中间件的数组,中间件会被格式化成形为&#123;route: route , handle : fn&#125;的匿名对象存放 return app;&#125;// 监听指定端口号proto.listen = function listen() &#123; var server = http.createServer(this); // this ——&gt; app函数对象,作为request事件的处理函数 return server.listen.apply(server, arguments); // 从 arguments 拿到端口号&#125;; connect框架的核心是use、handle、call三个方法，我们来分析一下这三个方法分别有什么作用。 use方法：添加中间件 12345678910111213141516171819202122232425262728293031323334353637// 添加中间件proto.use = function use(route, fn) &#123; var handle = fn; var path = route; // 如果参数只有一个，那么path默认是 '/', 传入的参数作为处理函数 if (typeof route !== 'string') &#123; handle = route; path = '/'; &#125; // 如果fn为一个app的实例，则将其自身handle方法的包裹给fn if (typeof handle.handle === 'function') &#123; var server = handle; server.route = path; handle = function (req, res, next) &#123; server.handle(req, res, next); &#125;; &#125; // 如果fn为一个http.Server实例，则fn为其request事件的第一个监听器 if (handle instanceof http.Server) &#123; handle = handle.listeners('request')[0]; &#125; // 如果route参数的以 '/' 结尾，则删除 '/' if (path[path.length - 1] === '/') &#123; path = path.slice(0, -1); &#125; // 把中间件添加到stack数组中 debug('use %s %s', path || '/', handle.name || 'anonymous'); this.stack.push(&#123; route: path, handle: handle &#125;); // 返回自身，以便继续链式调用 return this;&#125;; handle方法：根据当前路径找到stack中所有与之相匹配的中间件，通过call方法调用中间件处理函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970proto.handle = function handle(req, res, out) &#123; var index = 0; var protohost = getProtohost(req.url) || ''; var removed = ''; var slashAdded = false; var stack = this.stack; // final function handler var done = out || finalhandler(req, res, &#123; env: env, onerror: logerror &#125;); // store the original URL req.originalUrl = req.originalUrl || req.url; // 调用next方法传递的err信息，可以在下一个中间件处理函数的err参数中获取到 function next(err) &#123; if (slashAdded) &#123; req.url = req.url.substr(1); slashAdded = false; &#125; if (removed.length !== 0) &#123; req.url = protohost + removed + req.url.substr(protohost.length); removed = ''; &#125; // 取出第一个中间件，index+1，再次调用取出第二个中间件.... var layer = stack[index++]; // all done if (!layer) &#123; defer(done, err); return; &#125; // route data var path = parseUrl(req).pathname || '/'; var route = layer.route; // skip this layer if the route doesn't match if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) &#123; return next(err); &#125; // skip if route match does not border \"/\", \".\", or end var c = path.length &gt; route.length &amp;&amp; path[route.length]; if (c &amp;&amp; c !== '/' &amp;&amp; c !== '.') &#123; return next(err); &#125; // trim off the part of the url that matches the route if (route.length !== 0 &amp;&amp; route !== '/') &#123; removed = route; req.url = protohost + req.url.substr(protohost.length + removed.length); // ensure leading slash if (!protohost &amp;&amp; req.url[0] !== '/') &#123; req.url = '/' + req.url; slashAdded = true; &#125; &#125; // 执行handler中匹配到的中间件 call(layer.handle, route, err, req, res, next); &#125; next();&#125;; call方法:：执行handler中匹配到的中间件 123456789101112131415161718192021222324252627function call(handle, route, err, req, res, next) &#123; // handle函数的参数个数(3个参数为一般中间件，4个参数为错误处理中间件) // next参数接收的是上面定义的next函数，然后传入到中间件的handle函数中，handle函数同样通过next参数接 收，所以在中间件中调用next后会继续执行下一个中间件 var arity = handle.length; var error = err; var hasError = Boolean(err); debug('%s %s : %s', handle.name || '&lt;anonymous&gt;', route, req.originalUrl); try &#123; if (hasError &amp;&amp; arity === 4) &#123; // 执行错误处理中间件 handle(err, req, res, next); return; &#125; else if (!hasError &amp;&amp; arity &lt; 4) &#123; // 执行一般中间件 handle(req, res, next); return; &#125; &#125; catch (e) &#123; // replace the error error = e; &#125; // continue next(error);&#125; connect运行过程通过下面的这张图，总结一下connect工作流程，app.use方法负责把中间件添加到stack数组中，中间件会被格式化成形为{route: route , handle : fn}的匿名对象存放 ；app.handle方法根据当前路径找到stack中所有与之相匹配的中间件，并通过call方法调用中间件处理函数 ；app.call方法根据handle函数的参数个数(3个参数为一般中间件，4个参数为错误处理中间件) 来执行中间件，并把接收的next函数传给中间件。 完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196'use strict';// 引入依赖var debug = require('debug')('connect:dispatcher');var EventEmitter = require('events').EventEmitter;var finalhandler = require('finalhandler');var http = require('http');var merge = require('utils-merge');var parseUrl = require('parseurl');// 模块出口module.exports = createServer;// 判断当前环境，初始化proto 对象var env = process.env.NODE_ENV || 'development';var proto = &#123;&#125;;var defer = typeof setImmediate === 'function' ? setImmediate : function(fn)&#123; process.nextTick(fn.bind.apply(fn, arguments)) &#125;function createServer() &#123; // app 函数对象，可以添加属性和方法 function app(req, res, next)&#123; app.handle(req, res, next); &#125; // 相当于Object.assign merge(app, proto); // 继承proto的属性和方法 merge(app, EventEmitter.prototype); // 继承EventEmitter（事件派发器）属性和方法 app.route = '/'; app.stack = []; // 存放中间件的数组,中间件会被格式化成形为&#123;route: route , handle : fn&#125;的匿名对象存放 return app;&#125;// 监听指定端口号proto.listen = function listen() &#123; var server = http.createServer(this); // this ——&gt; app函数对象,作为request事件的处理函数 return server.listen.apply(server, arguments); // 从 arguments 拿到端口号&#125;;// 添加中间件proto.use = function use(route, fn) &#123; var handle = fn; var path = route; // 如果参数只有一个，那么path默认是 '/', 传入的参数作为处理函数 if (typeof route !== 'string') &#123; handle = route; path = '/'; &#125; // 如果fn为一个app的实例，则将其自身handle方法给fn if (typeof handle.handle === 'function') &#123; var server = handle; server.route = path; handle = function (req, res, next) &#123; server.handle(req, res, next); &#125;; &#125; // 如果fn为一个http.Server实例，则fn为其request事件的第一个监听器 if (handle instanceof http.Server) &#123; handle = handle.listeners('request')[0]; &#125; // 如果route参数的以 '/' 结尾，则删除 '/' if (path[path.length - 1] === '/') &#123; path = path.slice(0, -1); &#125; // 把中间件添加到stack数组中 debug('use %s %s', path || '/', handle.name || 'anonymous'); this.stack.push(&#123; route: path, handle: handle &#125;); // 返回自身，以便继续链式调用 return this;&#125;;// 这个函数作用是根据当前路径找到stack中所有与之相匹配的中间件，并通过call方法调用中间件处理函数proto.handle = function handle(req, res, out) &#123; var index = 0; var protohost = getProtohost(req.url) || ''; var removed = ''; var slashAdded = false; var stack = this.stack; // final function handler var done = out || finalhandler(req, res, &#123; env: env, onerror: logerror &#125;); // store the original URL req.originalUrl = req.originalUrl || req.url; function next(err) &#123; if (slashAdded) &#123; req.url = req.url.substr(1); slashAdded = false; &#125; if (removed.length !== 0) &#123; req.url = protohost + removed + req.url.substr(protohost.length); removed = ''; &#125; // next callback var layer = stack[index++]; // all done if (!layer) &#123; defer(done, err); return; &#125; // route data var path = parseUrl(req).pathname || '/'; var route = layer.route; // skip this layer if the route doesn't match if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) &#123; return next(err); &#125; // skip if route match does not border \"/\", \".\", or end var c = path.length &gt; route.length &amp;&amp; path[route.length]; if (c &amp;&amp; c !== '/' &amp;&amp; c !== '.') &#123; return next(err); &#125; // trim off the part of the url that matches the route if (route.length !== 0 &amp;&amp; route !== '/') &#123; removed = route; req.url = protohost + req.url.substr(protohost.length + removed.length); // ensure leading slash if (!protohost &amp;&amp; req.url[0] !== '/') &#123; req.url = '/' + req.url; slashAdded = true; &#125; &#125; // 通过call方法调用中间件的handle函数处理对应的路由 call(layer.handle, route, err, req, res, next); &#125; next();&#125;;function call(handle, route, err, req, res, next) &#123; // handle函数的参数个数(3个参数为一般中间件，4个参数为错误处理中间件) // next参数接收的是上面定义的next函数，然后传入到中间件的handle函数中，handle函数同样通过next参数接收，所以在中间件中调用next后会继续执行下一个中间件 var arity = handle.length; var error = err; var hasError = Boolean(err); debug('%s %s : %s', handle.name || '&lt;anonymous&gt;', route, req.originalUrl); try &#123; if (hasError &amp;&amp; arity === 4) &#123; // 执行错误处理中间件 handle(err, req, res, next); return; &#125; else if (!hasError &amp;&amp; arity &lt; 4) &#123; // 执行一般中间件 handle(req, res, next); return; &#125; &#125; catch (e) &#123; // replace the error error = e; &#125; // continue next(error);&#125;function logerror(err) &#123; if (env !== 'test') console.error(err.stack || err.toString());&#125;function getProtohost(url) &#123; if (url.length === 0 || url[0] === '/') &#123; return undefined; &#125; var searchIndex = url.indexOf('?'); var pathLength = searchIndex !== -1 ? searchIndex : url.length; var fqdnIndex = url.substr(0, pathLength).indexOf('://'); return fqdnIndex !== -1 ? url.substr(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;&#125;","tags":[{"name":"Express","slug":"Express","permalink":"https://gyunzhi.github.io/tags/Express/"}]},{"title":"Node基础知识","date":"2018-10-18T18:16:52.000Z","path":"2018/10/19/Node基础知识/","text":"module - 模块概述Node应用由模块组成，采用CommonJS模块化规范，在node中一个文件就是一个模块，每个模块都有自己的作用域。 特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 主要内容module对象​ CommonJS规范规定，每个模块内部，都有一个module对象，代表当前模块,它的exports属性 ​ 是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 ​ module对象的属性： 123456module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值。 require()​ Node使用CommonJS模块规范，内置的require()用于加载模块文件,require命令的基本功能是，读入 ​ 并执行一个JavaScript文件，然后返回该模块的module.exports属性。 exports变量​ 在模块中，还有一个变量exports，它是module.exports对象的引用，在使用exports变量时， ​ 注意不要破坏它和module.exports对象之间的引用关系。 ​ 我们经常看到这样的写法： ​ exports = module.exports = somethings ​ 上面的代码等价于: ​ module.exports = somethings ​ exports = module.exports ​ 原理很简单，即 module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 ​ exports = module.exports 让 exports 重新指向 module.exports 即可。 模块加载中的两个问题 路径问题：根据参数的不同格式，require命令去不同路径寻找模块文件。 ​ （1） 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。 ​ 比如，require(&#39;E:/NodeJs/module/2.js&#39;) ​ （2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（当前目录）的模块文件。 ​ 比如，require(&#39;./2.js&#39;) ​ （3）如果参数字符串不以“./“或”/“开头，则表示加载node的核心模块，或者是node_modules下面的模块 ​ 比如，require(&#39;fs&#39;) 文件查找问题 ​ (1)首先按照加载的模块的文件名称进行查找 ​ (2)如果没有找到，则会在模块文件名称后面加上.js后缀，进行查找 ​ (3)如果还没有找到，则会在模块文件名称后面加上.json后缀，进行查找 ​ (4)如果还没有找到，则会在模块文件名称后面加上.node后缀，进行查找 ​ (5)以上都没有找到就会报错 global - 全局变量全局变量在所有模块中均可使用。 以下变量虽然看起来像全局变量，但实际上不是。 它们的作用域只在模块内，详见 module文档： __dirname __filename exports module require() process - 进程process对象是一个全局变量，可以在任何地方都能访问到它，通过这个对象提供的属性和方法，使我们可以对当前运行的程序的进程进行访问和控制。 1234567process.argv 返回一个包含命令行参数的数组process.env 返回用户环境信息process.version 返回node版本信息process.versions 返回node及node依赖包版本信息process.pid 返回进程的pidprocess.title 返回当前进程显示的名称process.arch 返回CPU处理器架构 1234567891011121314151617181920212223242526stdin、stdout：标准输入输出流（I/O操作）process.stdin.resume() // 开启输入流, 监听输入流数据，默认开启process.stdin.pause() // 关闭输入流例1: 监听用户的输入数据process.stdin.on('data', function (chunnk)&#123; console.log('用户输入了:' + chunnk ) process.stdin.pause();&#125;);例2: 要求用户输入两个数值，然后把和输出到终端var num1, num2;process.stdout.write('请输入num1的值：');process.stdin.on('data', function (chunk) &#123; if (!num1) &#123; num1 = Number(chunk); process.stdout.write('请输入num2的值: '); &#125; else &#123; num2 = Number(chunk) process.stdout.write('结果是：' + (num1 + num2)) process.stdin.pause() &#125;&#125;) 提示：vscode的内置调试控制台默认不从stdout的输出流中抓取内容，需要在vscode的启动配置(launch.json)中添加如下配置： 1234567891011121314151617&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", \"request\": \"launch\", \"outputCapture\": \"std\", // 抓取stdout输出流的内容 \"console\": \"externalTerminal\", // 另外打开控制台 \"name\": \"启动程序\", \"program\": \"$&#123;file&#125;\" &#125; ]&#125; BufferBuffer 类用于操作二进制数据流 。 12345678910111213141516171819202122232425262728293031323334(1) new Buffer(size) （size [Number]） 创建一个Buffer对象，并为这个对象分配空间大小 var bf = new Buffer(5) console.log(bf) // 当我们为一个Buffer对象分配空间大小之后，其长度是固定的，不能更改 bf[5]=1; console.log(bf);(2) new Buffer([array]) 创建一个Buffer对象，并初始化 var bf=new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]); console.log(bf);(3) new Buffer(sring,[encoding]) 创建一个Buffer对象，并使用字符串初始化,第二个参数用于指定字符串编码 var bf=new Buffer('miaov','utf-8'); console.log(bf); console.log(bf[0].toString(16)); console.log(String.fromCharCode(bf[0])); console.log(String.fromCharCode(bf[1])); console.log(String.fromCharCode(bf[2])); console.log(String.fromCharCode(bf[3])); (4) buf.length // 输出的是字节长度 var str1='miaov'; console.log(str1.length); var bf=new Buffer(str1); console.log(bf.length); var str2='妙味'; console.log(str2.length); var bf2=new Buffer(str2); console.log(bf2.length); // 输出的是字节长度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162(1) buf.write(string[, offset[, length]][, encoding]) 将字符串写入到Buffer中 string 要写入 buf 的字符串。 offset 从Buffer对象中的第几位开始写入。默认: 0。 length 写入的字符串的长度。默认: buf.length - offset。 encoding 字符编码。默认: 'utf8'。 var str='miaov'; var bf=new Buffer(5); bf.write(str); bf.write(str,1); console.log(bf); bf.write(str,1,2); console.log(bf);(2) buf.toString([encoding[, start[, end]]]) 根据encoding参数，将Buffer对象输出为字符串 var bf=new Buffer('miaov'); console.log(bf.toString()); console.log(bf.toString('utf-8',1,3)); //不包含结束位 var bf2=new Buffer('妙味'); console.log(bf2); console.log(bf2.toString('utf-8',1)); (3) buf.toJSON() 将Buffer对象转换为JSON格式 var bf=new Buffer('miaov'); console.log(bf.toJSON()); // &#123;type: 'Buffer', data:[109,105,97,111,118]&#125; (4) buf.slice([start[, end]]) 返回一个新的buffer，这个buffer将和老的buffer引用相同的内存地址 注意：修改这个新的buffer对象，会改变原来老的buffer对象 var bf=new Buffer('miaov'); console.log(bf); var bf2=bf.slice(2); console.log(bf2); bf2[0]=2; console.log(bf2); console.log(bf); // 老的buffer也被改变了 (5) bf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]) 进行buffer的拷贝 修改新的buffer对象，不会会改变原来老的buffer对象 var bf=new Buffer('miaov'); console.log(bf); var bf2=new Buffer(6); bf.copy(bf2); //将bf中的内容拷贝到bf2中 console.log(bf2); bf2[0]=2; console.log(bf2); console.log(bf); 123456789101112131415静态方法Buffer.isEncoding('utf-8') 检测Buffer对象是否支持某种编码Buffer.isBuffer(bf) 判断某个对象是否是Buffer对象Buffer.byteLength(str) 返回该字符串的字节长度，encoding编码默认是utf-8Buffer.concat(arr,[totallLength]) 返回一个将传入的buffer数组中所有的buffer对象拼接在一起新的buffer对象var str1='miaov';var str2='妙味';var arr=[new Buffer(str1),new Buffer(str2)];var bf=Buffer.concat(arr,11); // 当第二个参数不给的时候，程序会默认计算buffer数组的总字节长度 123456789// 标准输入输出流中的内容也是二进制数据process.stdout.write('请输入内容:');process.stdin.resume();process.stdin.on('data',function (chunk)&#123; console.log(chunk); // &lt;Buffer 61 0a&gt; 0a：回车 console.log(chunk.toString()); console.log('输入的内容是：' + chunk); // 用+进行字符串拼接时，会自动对chunk进行字符串转换 process.stdin.pause();&#125;) fs - 文件系统fs 模块提供了一些 API，用于与文件系统进行交互，所有的文件系统操作都有异步和同步两种形式。 读写操作12345678910111213141516171819202122（1）打开一个文件 fs.open(path,flags,[mode],callback) 异步 fs.openSync(path, flags, [mode]) 同步 path: 文件路径 flags: 打开文件的模式 读/写 mode: 设置文件的模式 读/写/执行 4/2/1 callback: err: 文件打开失败时错误信息保存在err对象里面，如果成功err为null fd： 打开的文件的标识 var fs = require('fs'); var fileName = __dirname + '/' + '1.txt' //异步方式 fs.open(fileName, 'r', function (err, fd) &#123; console.log(fd); &#125;) //同步方式 var fd = fs.openSync(fileName, 'r'); console.log(fd); 123456789101112131415161718192021222324252627282930313233343536373839404142（2）读取文件内容，从指定的文档标识符fd读取文件数据 fs.read(fd, buffer, offset, length, position, callback) 异步 fs.readSync(fd, buffer, offset, length, position) 同步,返回bytesRead的个数 fd: 通过open方法成功打开一个文件返回的编号,用来标识打开的文件 buffer：数据将被写入到的 buffer 对象 offset: 读取的内容添加到buffer中的起始位置 length: 是一个整数，指定要读取的字节数 position: 读取文件的起始位置 callback: error: 文件读取失败时错误信息保存在err对象里面，如果成功err为null bytesRead: 读取的字节数 buffer: 读取完成之后的buffer对象 var fs = require('fs'); var fileName = __dirname + '/' + '1.txt' // 异步方式 fs.open(fileName, 'r', function (err, fd) &#123; if (err) &#123; console.log('文件打开失败'); &#125; else &#123; var bf1 = new Buffer(10); fs.read(fd, bf1, 0, 4, null, function (error, bytesRead, buf) &#123; console.log(bytesRead); console.log(buf); console.log(buf.toString()); &#125;) &#125; &#125;) // 同步方式 fs.open(fileName, 'r', function (err, fd) &#123; if (err) &#123; console.log('文件打开失败'); &#125; else &#123; var bf1 = new Buffer(10); var bytesRead = fs.readSync(fd, bf1, 0, 2, null) console.log(bytesRead) &#125; &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152(3) 写入数据到指定文件中/关闭打开的文件 异步 写入 buffer 到 fd 指定的文件 fs.write(fd, buffer, offset, length[, position], callback) fd: 打开文件的标识 buffer：要写入的数据 offset：buffer对象中要写入的数据的起始位置 length: 是一个整数，指定要写入的字节数 position：指向从文件开始写入数据的的起始位置 callback： error: 文件写入失败时错误信息保存在error对象里面，如果成功error为null bytesWritten: 写入的字节数 buffer: 读取完成之后的buffer对象 写入 string 到 fd 指定的文件，如果 string 不是一个字符串，则该值将被强制转换为一个字符串。 fs.write(fd, string[, position[, encoding]], callback) fd: 打开文件的标识 string：写入string 到 fd 指定的文件 position：指向从文件开始写入数据的的起始位置 callback： error: 文件写入失败时错误信息保存在error对象里面，如果成功error为null written: 写入的字节数 string: 读取完成之后的buffer对象 关闭一个打开的文件 fs.close(fd, callback) 同步 fs.writeSync(fd, buffer, offset, length[, position]) fs.writeSync(fd, data[, position[, encoding]]) fs.closeSync(fd) // 当我们要对打开的文件进行写操作的时候，打开文件的模式应该是读写方式 r+ fs.open(fileName, 'r+', function (err, fd) &#123; if (err) &#123; console.log('打开文件失败'); &#125; else &#123; var bf = new Buffer('abcd'); fs.write(fd, bf, 0, 4, 0, function (err, bytesWritten, buf) &#123; console.log(bytesWritten) console.log(buf.toString()) &#125;) fs.write(fd, '123', 3, 'utf-8', function (err, written, string) &#123; console.log(written) console.log(string) &#125;); fs.close(fd, function () &#123;&#125;); fs.write(fd, '9', 7, 'utf-8', function () &#123;&#125;); //文件已经关闭，这段代码不会执行 &#125;&#125;) fs.open、fs.read、 fs.write等是更底层的操作，node提供了一些封装好的方法供开发者调用，可以更方便的对文件进行读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455（1）写入数据 fs.writeFlie(filename, data, [options], callback) 异步的将数据写入一个文件，如果该文件不存在，则新建，如果存在则覆盖原来的内容。data 可以是一个string，也可以是一个原生buffer。 fs.writeFileSync(filename, data, [options]) fs.appendFile(filename, data, [options], callback) 异步的将数据写入一个文件，如果该文件不存在，则新建，如果存在则添加到原内容后面。data 可以是一个string，也可以是一个原生buffer。 fs.appendFileSync(filename, data, [options]) fs.access(path[, mode], callback) 检查文件是否存在于当前目录 var fs = require('fs'); var filename = __dirname + '/' + '2.txt'; fs.writeFile(filename, 'hello', function (err) &#123; console.log(err); &#125;) fs.appendFile(filename, '-leo', function (err) &#123; console.log(err); &#125;) fs.access(filename, fs.constants.F_OK, (err) =&gt; &#123; console.log(`$&#123;filename&#125; $&#123;err ? '不存在' : '存在'&#125;`); &#125;) // 结合fs.access对文件进行读取操作 fs.access(filename, fs.constants.F_OK, (err) =&gt; &#123; if(err) &#123; fs.writeFile(filename,'hello',function (err)&#123; if(err)&#123; console.log('出错了'); &#125;else&#123; console.log('创建新文件成功'); &#125; &#125;); &#125; else &#123; fs.appendFile(filename,'-leo',function (err)&#123; if(err)&#123; console.log('新的内容添加失败'); &#125;else&#123; console.log('新的内容添加成功'); &#125; &#125;) &#125; &#125;) // 同步模式 fs.access(filename, fs.constants.F_OK, (err) =&gt; &#123; if(err) &#123; fs.writeFileSync(filename,'miaov'); console.log('新文件创建成功'); &#125; else &#123; fs.appendFile(filename,'-leo'); console.log('新内容添加成功'); &#125; &#125;) 1234567891011121314（2）读取数据 fs.readFile(filename, [options], callback) 异步读取一个文件的全部内容 fs.readFileSync(filename, [options]) var fs = require('fs'); var filename = __dirname + '/' + '2.txt'; fs.readFile(filename, function (err, data) &#123; if (err) &#123; console.log(' 文件读取失败'); &#125; else &#123; console.log(data.toString()); &#125; &#125;) 常用的文件操作12345678910111213141516171819202122232425262728293031323334 fs.unlink(path, callback) 删除一个文件 fs.rename(oldPath, newPath, callback) 重命名 fs.stat(path, callback) 读取文件信息 fs.watch(filename, [options], [listener]) 监控文件的修改 var fs = require('fs'); var filename = __dirname + '/' + '2.txt'; fs.unlink(filename,function (err)&#123; if(err)&#123; console.log('删除成功'); &#125;else&#123; console.log('删除失败'); &#125; &#125;)fs.rename(filename,__dirname + '/' + '3.txt',function (err)&#123; if(err)&#123; console.log('重命名失败'); &#125;else&#123; console.log('重命名成功'); &#125; &#125;)fs.stat(filename, function (err, stats) &#123; console.log(stats);&#125;)fs.watch(filename, function (eventType, fileName) &#123; if (fileName) &#123; console.log(eventType); console.log(fileName + '发生了改变'); &#125; &#125;) 常用的文件夹操作123456789101112131415161718192021222324252627282930313233fs.mkdir(path, [mode], callback) 创建一个文件夹fs.rmdir(path, callback) 删除一个文件夹fs.readdir(path, callback) 读取文件夹var fs = require('fs'); fs.mkdir(__dirname + '/1', function (err) &#123; console.log(err);&#125;)fs.rmdir(__dirname + '/1',function (err)&#123; console.log(arguments);&#125;)fs.readdir(__dirname, function (err, fileList) &#123; // console.log(fileList); // 返回值是一个数组，包含了该文件夹下所有文件 fileList.forEach(function (item) &#123; fs.stat(__dirname + '/' + item, function (err, stats) &#123; switch (stats.mode) &#123; case 16822: console.log('[文件夹]: ' + item); break; case 33206: console.log('[文件]: ' + item); break; default: console.log('其他类型: ' + item); break; &#125; &#125;) &#125;)&#125;) http-HTTP 通过http模块，可以非常方便的搭建一个http服务器。 搭建http服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 加载一个http模块 var http = require('http'); （1） 通过http模块下的 createServer 创建并返回一个http服务器对象 http.createServer([requestListener]) requestListener : 监听到客户端连接的回调函数(request事件的回调函数，也可以采用下面的写法) var server = http.createServer(); （2） 监听客户端连接请求，只有当调用了listen方法以后，服务器才开始工作 server.listen(port, [hostname], [backlog], [callback]) port : 监听的端口 hostname : 主机名（IP/域名) backlog : 连接等待队列的最大长度 callback : 调用listen方法并成功开启监听以后，会触发一个listening事件，callback将作为该事件的 执行函数 server.listen(8080, 'localhost'); (3) error 事件 当服务开启失败的时候触发的事件 参数err : 具体的错误对象 server.on('error', function () &#123; console.log('err'); &#125;) (4) 当server调用listen方法并成功开始监听以后触发的事件，该事件的回调也可以在listen方法中使用 server.on('listening', function () &#123; console.log('listenning'); &#125;)(5) request事件: 当有客户端发送请求的时候触发 参数： req对象 ：通过它我们可以获取到这次请求的一些信息，比如头信息，数据等 res对象 ：通过他我们可以向该次请求的客户端输出返回响应 req对象: httpVersion : 使用的http协议的版本 headers : 请求头信息中的数据 url : 请求的地址 method : 请求方式 res对象 write(chunk, [encoding]) : 发送一个数据块到响应正文中 end([chunk], [encoding]) : 当所有的正文和头信息发送完成以后调用该方法告诉服务器数据已经全部发送完成了，这个方法在每次完成信息发送以后必须调用，并且是最后调用 statusCode : 该属性用来设置返回的状态码 setHeader(name, value) : 设置返回头信息 writeHead(statusCode, [reasonPhrase], [headers]) : 这个方法只能在当前请求中使用一次，并且必须在response.end()之前调用 server.on('request',function (req,res)&#123; console.log('有用户连接进来了'); res.writeHead(200,'OK',&#123; //'content-type':'text/plain',//纯文本 'content-type':'text/html;charset=utf-8' &#125;); res.write('&lt;h1&gt;你好，欢迎学习node&lt;/h1&gt;'); res.end(); // 当所有的正文和头信息发送完成以后调用该方法告诉服务器数据已经全部发送完成了 &#125;) url处理1234567891011121314151617181920212223242526272829303132333435363738394041424344上一个例子中，监听到request事件时(当有客户端发送请求时)，返回的数据都是一样的实际开发过程中，对于不同请求，我们需要返回不同的数据,所以需要用到url模块对req对象中的url进行处理var http = require('http');var url = require('url'); (1)url.parse(request.url): 对url格式的字符串进行解析，返回一个对象,不同的url处理之后返回的数据是不同的 var urlObj = url.parse('http://www.baidu.com:8080/a/b?age=23&amp;name=jack#p=1')console.log(urlObj);(2)利用url模块处理request.url，对于不同的pathname(路径),返回不同的数据,即做出不同的响应var server = http.createServer();server.listen(8080, 'localhost');server.on('request', function (req, res) &#123; //req.url: 访问路径 //console.log(req.url); var urlObj = url.parse(req.url); switch (urlObj.pathname) &#123; case '/': //首页 res.writeHead(200, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end('&lt;h1&gt;这是首页&lt;/h1&gt;'); break; case '/user': //个人中心 res.writeHead(200, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end('&lt;h1&gt;这是个人中心&lt;/h1&gt;'); break; default: //处理其他情况 res.writeHead(404, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end('&lt;h1&gt;页面不见了&lt;/h1&gt;'); break; &#125;&#125;) 请求数据处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 使用fs模块实现nodejs代码和html的分离 queryString模块 对get和和post方法提交的数据进行处理 queryString.parse() : 将一个 querystring 反序列化为一个对象 var http = require('http'); var url = require('url'); var fs = require('fs'); 通过req.method 拿到请求的方法 (1) get请求的数据处理 ：get请求的数据在querystring中，通过url.parse解析之后可以存放在query属性中。 qs.parse(urlObj.query) (2) post请求的数据处理 : post发送的数据会被写入缓冲区中(buffer)，需要通过resquest的data和end事件来获取数据，并且用 + 进行字符串拼接或者 chunk.toString()，对chunk进行字符串转换。var qs = require('querystring');var server = http.createServer();//保存html目录路径var HtmlDir = __dirname + '/html';server.listen(8080, 'localhost');server.on('request', function (req, res) &#123; var urlObj = url.parse(req.url); switch (urlObj.pathname) &#123; case '/': // 首页 sendData(HtmlDir + '/index.html', req, res); break; case '/user': // 个人中心 sendData(HtmlDir + '/user.html', req, res); break; case '/login': // 登录页面 sendData(HtmlDir + '/login.html', req, res); break; case '/login/check': // 登录验证 // get请求 // qs.parse(urlObj.query) // post请求 nodejs用req.on(data)接收客户端的post请求数据 if (req.method.toUpperCase() == 'POST') &#123; var str = ''; req.on('data', function (chunk) &#123; str += chunk; // 用 + 进行字符串拼接时，会自动对chunk进行字符串转换，等同于 chunk.toString() &#125;) req.on('end', function () &#123; console.log(qs.parse(str)); &#125;) &#125; break; default: //处理其他情况 break; &#125;&#125;)function sendData(file, req, res) &#123; fs.readFile(file, function (err, data) &#123; if (err) &#123; res.writeHead(404, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end('&lt;h1&gt;页面不见了......&lt;/h1&gt;'); &#125; else &#123; res.writeHead(200, &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end(data); &#125; &#125;)&#125;总结： http模块配合url模块、fs模块、queryString搭建了一个对于不同的http请求进行响应的web服务器","tags":[{"name":"Node","slug":"Node","permalink":"https://gyunzhi.github.io/tags/Node/"}]},{"title":"Node、NPM安装","date":"2018-10-06T13:09:59.000Z","path":"2018/10/06/Node、NPM安装/","text":"Node环境的安装官网下载安装官方地址：https://nodejs.org/en/ 或 https://nodejs.org/zh-cn/ 下载完成之后直接双击安装即可，安装完成之后会自动添加node、npm环境变量，安装完成之后打开控制台，执行以下命令，测试是否安装成功 12node -v 查看 node 版本npm -v 查看 npm 版本 使用nvm安装 操作系统环境： windows 7 x64 安装nvm之前如果已经安装了node，没有关系，直接安装nvm，安装完成之后nvm会自动管理已经安装好的 node。 （1）安装nvm 安装nvm-windows ，注意安装路径不要有中文或者空格，安装完成之后会自动添加环境变量 安装过程有一个Set Node.js Symlink的步骤，作用是设置一个快捷方式，这个路径可以nvm一样，也可以不一样，看个人习惯。 安装成功之后我们可以看一下nvm/settings.txt这个文件 12root: D:\\nvm // nvm安装目录path: C:\\Program Files\\nodejs //快捷方式目录 执行以下代码，测试是否安装成功 12nvm version1.1.7 // 安装成功 （2）安装node 安装成功之后，接下来使用nvm命令来安装和使用指定的node版本 12345nvm install &lt;version&gt; &lt;arch&gt; // 安装指定版本的nodenvm install 8.11.3nvm install latest // 安装最新版本nvm install 8.11.3 32 // 32位操作系统需指定arch值，声明系统架构为32位 123456nvm list // 查看已经安装的node 8.11.3 10.12.0 nvm use 8.11.3 // 使用指定版本的node Now using node v8.11.3 (64-bit) （3）快捷方式的作用，直接在安装nvm的时候设置了一个快捷方式目录，这里做一个说明，在C:\\Program Files下会有一个nodejs，它是一个快捷方式，和我们当前nvm使用的那个node版本对应的文件夹是管理在一起的，如现在node的版本是8.11.3，那么当前这个快捷方式的文件夹和D:\\nvm\\v8.11.3文件夹是关联的。当使用nvm use &lt;version&gt;切换其他的node版本后，它就会和切换之后的node对应的文件夹进行关联。 NPM全局模块和局部模块在安装node的同时，会一起安装好npm模块，安装完成后，要设置镜像源，以加快下载速度： 12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 设置完成之后可以在C:\\Users\\Administrator\\.npmrc目录下查看到刚才的配置 我们知道npm安装的依赖可以是全局的，也可以是局部的，局部的模块是安装在项目中的的node_modules中。全局安装的模块有一些不同，可以通过npm config get prefix 查看全局模块安装的位置： 1234567（1）通过官网下载安装的node npm config get prefix C:\\Users\\Administrator\\AppData\\Roaming\\npm // 默认位置（2）通过nvm安装的node npm config get prefix C:\\Program Files\\nodejs npm中还有一个缓存目录，可以通过npm config get cache查看 12npm config get cacheC:\\Users\\Administrator\\AppData\\Roaming\\npm-cache 修改全局模块目录和缓存目录 12345npm config set prefix 'C:\\Program Files\\nodejs\\node_global'npm config set cache 'C:\\Program Files\\nodejs\\node_cache'// 安装完成之后需配置环境变量Path \"，输入'C:\\Program Files\\nodejs\\node_global' 安装yarn，我个人习惯使用yarn，所以在配置好npm后会先下载yarn，并且配置镜像源 12yarn config set registry https://registry.npm.taobao.org --global yarn config set disturl https://npm.taobao.org/dist --global 同样的yarn的依赖也分为全局和局部依赖，我们可以通过yarn global dir 查看yarn全局安装的模块： 12yarn global dirC:\\Users\\Administrator\\AppData\\Local\\Yarn\\Data\\global 注意事项：个人建议先安装node，在安装nvm，然后然nvm自动管理已经安装好的node，因为卸载node，通过nvm去安装时，全局模块安装的默认位置在C:\\Program Files\\nodejs，这个时候需要我们去修改手动修改全局模块和缓存目录，其次不能使用yarn去安装全局模块，原因目前暂时不知道。","tags":[{"name":"Node","slug":"Node","permalink":"https://gyunzhi.github.io/tags/Node/"}]},{"title":"Javascript异步编程的演进","date":"2018-09-09T13:12:56.000Z","path":"2018/09/09/Javascript异步编程的演进/","text":"一、Javascript 异步的由来Javascript 单线程大家都知道 js 是单线程的，那为什么要是单线程的呢？ 因为 js 的运用场景是浏览器，包含了很多用户的交互，如果是多线程，那一个线程要在某个 DOM 上添加内容，另一个线程直接要删除这个 DOM，那浏览器到底听哪个的好呢？所以为了降低复杂性，js 从一诞生，就是单线程，这也是这门语言的核心特征，因为 js 一开始就是为浏览器而生的 既然是单线程，也就是每次只执行一个任务，只有等到当前任务执行完毕，才能执行后面的任务，这些任务会形成一个任务队列，排队等候执行 就像大家去超市买东西排队结账，得前面一个人付完钱，排在他后面的那个才能买单。但是如果前面一个任务很耗时，比如正常每个人手里都是拿着一两样东西等着排队，而你前面那位大哥推着满满一车的东西，你是不是得崩溃了？ 所以像我们平时遇到的浏览器无响应和页面假死，往往是因为某段 js 代码执行时间过长，或者直接陷入死循环，导致页面卡死，后面的任务当然就无法继续执行了 但是，在前端的某些任务的确是非常耗时的，比如网络请求、定时器和事件监听等等，如果让他们和别的任务一样都老老实实的排队等待执行的话，执行效率会非常低。所以，这时候浏览器为这些耗时的任务开辟了另外的线程，主要包括事件触发线程、定时器触发线程和异步 HTTP 请求线程 浏览器多线程浏览器渲染进程是多线程的，它包含如下线程： GUI 渲染线程 JS 引擎线程 事件触发线程 定时器触发线程 异步 HTTP 请求线程 1、GUI 渲染线程负责渲染浏览器界面，解析 HTML、CSS当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行GUI 渲染线程与 JS 引擎线程是互斥的，因为 JS 可以操作 DOM 元素， 从而影响到 GUI 的渲染结果，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行 2、JS 引擎线程JS 内核（例如V8引擎），负责处理 Javascript 脚本程序JS 引擎一直等待着任务队列中任务的到来，然后加以处理因为 GUI 渲染线程与JS引擎线程是互斥的，所以如果 JS 执行时间过长，页面渲染就不连贯，造成页面渲染加载阻塞 3、事件触发线程由于 JS 引擎这个单线程的家伙自己都忙不过来，所以需要浏览器另开一个线程协助它待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 4、定时触发器线程setInterval 与 setTimeout所在线程JS 引擎阻塞状态下计时不准确，所以由浏览器另开线程单独计时计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行 5、异步 HTTP 请求线程如果请求有回调事件，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等 JS 引擎空闲后执行 事件循环（Event Loop）js 一直在做一个工作，就是从任务队列里提取任务，放到主线程里执行，看下面这张图： JS 运行时引擎(runtime)：也就是 js 线程，由内存堆(heap)和调用栈(stack)组成，其中内存堆是用于内存分配，调用栈是代码执行时的栈 Web APIs：上文中说到的浏览器为异步任务单独开辟的线程在这里可以统一理解为 Web APIs 回调队列(callback queue)：也就是任务队列，上面 Web APIs 子线程任务执行结束后会将任务的回调函数推入回调队列 事件循环(Event Loop)：事件轮询机制，观察运行时调用栈是否为空，如果为空，将回调队列中的任务推到调用栈，回调队列遵循先入先出(FIFO)的原则，也就是按照子线程执行任务完成顺序依次被调用 我们再来看一个经典的问题，下面代码输出的结果是什么： 1234setTimeout(function()&#123; console.log(1)&#125;,0);console.log(2) 结果是 2、1，因为执行 setTimeout 会立即交给浏览器的定时触发器线程去处理，计时完毕后会把匿名函数放到任务队列里等待 js 主线程调用，但这个时候 js 线程里的 stack 并不是空的，因为还有一句 console.log(2)。 要等到 console.log(2)执行完之后，才通过事件循环把匿名函数推到 stack 里面去执行 小结js 从诞生起是单线程的，所谓的 js 异步，其实是由单线程的 js、多线程的宿主浏览器和事件循环机制共同作用而成 二、Javascript 异步编程的演进1、回调函数实现 js 异步编程最基础方式的就是『回调函数』，这里列举几个大家熟悉的场景，比如：Ajax 请求、IO 操作或者定时器 123456ajax(url, function()&#123; //回调函数&#125;);setTimeOut(function()&#123; //回调函数&#125;, 1000) 如上面代码，回调本身没什么毛病，是比较好用的，但是随着 Web 前端的复杂度不断提高，以及 js 应用场景的不断拓宽，光是回调已经不够用了 因为我们阅读和编写程序是顺序的，对于复杂的回调函数会不易理解，所以我们需要一种同步的、顺序的方式来表达异步，看下面栗子： 1234567891011121314151617181920// 回调函数实现两数相加，两个数字都是异步获取// 这里 fetchX() 和 fetchY() 是异步获取数字的 Ajax 请求，接受一个回调函数作为参数function add(getX, getY, cb) &#123; var x, y getX(function(xVal) &#123; x = xVal if (y != undefined) &#123; cb(x + y) &#125; &#125;) getY(function(yVal) &#123; y = yVal if(x != undefined) &#123; cb(x + y) &#125; &#125;)&#125;add(fetchX, fetchY, function(sum) &#123; console.log(sum)&#125;) 再来看下用 Promise 怎么实现： 123456789101112//Promise 实现两数相加function add(xPromise, yPromise) &#123; return Promise.all([xPromise, yPromise]) .then(function(values) &#123; return values[0] + values[1] &#125;)&#125;//这里 fetchX()、fetchY()返回相应值的 Promiseadd(fetchX(), fetchY()) .then(function(sum)&#123; console.log(sum) &#125;) 这里只需保证 fetchX() 和 fetchY() 返回的是 Promise，然后直接用 Promise.all 即可 显然第二种处理起来是不是顺畅得多？ 2、PromisePromise 是一种弥补回调函数不足的异步解决方案，最早由社区提出并实现，后来写进了 es6 规范 简单地说，Promise 是一个特殊的对象，它可以表示异步操作的成功或者失败，同时返回异步操作的执行结果 理解 Promise什么意思呢，上面的解释可能还是不够直观，咱们举个栗子： 假设你苦苦追求的女神，有一天终于禁不住你的死缠烂打，答应跟你去看电影了。那答应跟你去看电影这个事情就是一个承诺（Promise）。可其实你心里也没底，你并不知道女神会不会真的陪你去看电影，女神可能兑现承诺，也可能放你鸽子 这就是 Promise，一个 Promise 有三种状态： Promise 是待定的（pending）： 你并不知道女神会不会真的陪你去看电影 Promise 是已解决的（resolved）：女神兑现承诺 Promise 是被拒绝的（rejected）: 被放鸽子 创建一个 Promise12345678910111213141516171819let isHayyp = falselet watchingMovies = new Promise(function (resolve, reject) &#123; if (isHayyp) &#123; const movie = &#123; name: '海王', time: '2018-12-27 18:20' &#125; resolve(movie) &#125; else &#123; reject(new Error('女神心情不好')) &#125;&#125;)watchingMovies.then((movie) =&gt; &#123; // 女神兑现承诺，一起去看了电影 // 然后再一起去吃饭&#125;, (err) =&gt; &#123; // 女神心情不好，被放鸽子了，回家打游戏&#125;) 以上两段代码，第一段是调用 Promise 构造函数，第二段是调用了 Promise 实例的 .then 方法 构造函数 构造函数接受一个函数作为参数 调用构造函数得到实例 watchingMovies 的同时，作为参数的函数会立即执行 参数函数接受两个回调函数参数 resolve 和 reject 在参数函数被执行的过程中，如果在其内部调用 resolve，会将 watchingMovies 的状态变成 fulfilled，或者调用 reject，会将 watchingMovies 的状态变成 rejected 调用 .then 调用 .then 可以为实例 p 注册两种状态回调函数 当实例 watchingMovies 的状态为 fulfilled，会触发第一个函数执行 当实例 watchingMovies 的状态为 rejected，则触发第二个函数执行 我们结合上面讲的 js 异步，再来看下面这段代码： 12345678910let promise = new Promise(function(resolve, reject) &#123; console.log(1) resolve()&#125;)promise.then(function() &#123; console.log(2)&#125;)console.log(3) 打印结果是 132，Promise 新建后立即执行，所以首先输出的是 1。然后，then 方法注册的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 2 最后输出 Promise APIPromise 的 API 分为构造函数、实例方法和静态方法 1个构造函数： new Promise 3个实例方法：.then 、 .catch 和 .finally 4个静态方法：Promise.all、Promise.race、Promise.resolve 和 Promise.reject #####1、.then方法 .then方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 .then 方法后面再调用另一个 .then 方法 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post&#125;).then(function(post) &#123; // ...&#125;) 上面的代码使用 .then 方法，依次注册了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数 #####2、.catch方法 处理异常的推荐写法 123456789101112// 不推荐promise.then((data) =&gt; &#123; // success&#125;, (err) =&gt; &#123; // error&#125;)// 推荐promise.then((data) =&gt; &#123; // success&#125;).catch(err =&gt; &#123; // error&#125;) 因为 catch 可以捕获到 then 里的异常 Promise 对象的错误具有『冒泡』性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 捕获 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL)&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;) 上面代码中，一共有三个 Promise 对象：一个由 getJSON 产生，两个由 then 产生。它们之中任何一个抛出的错误，都会被最后一个 catch 捕获 #####3、Promise.all方法 Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例 1const p = Promise.all([p1, p2, p3]) 上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例 p 的状态由p1、p2、p3决定，分成两种情况： （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数 12345678910// 生成一个 Promise 对象的数组const promiseList = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\")&#125;)Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;) 上面代码中，promiseList 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled，或者其中有一个变为 rejected，才会调用 Promise.all 方法后面的回调函数 #####4、Promise.race方法 Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例 1const p = Promise.race([p1, p2, p3]) 但不同的是，这里只要 p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数 #####5、Promise.resolve 和 Promise.reject方法 Promise.resolve 会返回一个状态为 fulfilled 状态的 Promise 对象，Promise.reject 与 Promise.resolve 同理，区别在于返回的 Promise 对象状态为 rejected Promise.resolve 等价于下面的写法： 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise 和 setTimeout 的执行顺序12345678910setTimeout(function () &#123; console.log(1)&#125;, 0)new Promise(function (resolve) &#123; console.log(2) resolve()&#125;).then(function () &#123; console.log(3)&#125;)console.log(4) 以上代码运行结果是 2431，为什么不是 2413，不是 setTimeout 先加入任务队列的么？ 所以这里又要从任务队列说起了，任务队列可以细分为 MacroTask Queue(宏任务队列) 和 MicroTask Queue(微任务队列) 两种 整个 script 代码放在了宏任务队列，setTimeout 也放在了宏任务队列，但 promise.then 放到了微任务队列 这两个队列的执行顺序如下： 取宏任务队列里第一个 task，执行之 把微任务队列里所有 task 执行完 再取宏任务队列里下一个 task 执行之，周而复始 代码开始执行时，所有这些代码在宏任务队列中，取出来执行之。 后面遇到了setTimeout，又加入到macrotask queue中， 然后，遇到了 promise.then，放入到了另一个队列，微任务队列。 等整个 stack 执行完后， 下一步该取的是微任务队列中的任务了。 因此 promise.then 的回调比 setTimeout 先执行 3、Generator 函数（生成器函数）Generator 函数，也可以叫生成器函数，是 ES6 提供的一种异步编程解决方案，执行生成器函数会返回一个迭代器对象，所以我们先来看下什么是迭代器。 迭代器迭代器并不是某一个语法或者对象，而是一个协议，只要遵循了这个协议，所实现的都是迭代器对象，下面我们来看一个简易的迭代器： 1234567891011121314151617function makeIterator(array) &#123; var nextIndex = 0 // 返回迭代器对象 return &#123; // next() 方法返回的结果对象 next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125; &#125; &#125;&#125;var it = makeIterator(['a', 'b'])it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 上面代码定义了一个makeIterator函数，它是一个迭代器生成函数，作用就是返回一个迭代器对象。对数组[&#39;a&#39;, &#39;b&#39;]执行这个函数，就会返回该数组的迭代器对象it 迭代器对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束 生成器借助于迭代器的这个特征，我们现在可以理解一下生成器，字面意思呢，就是生成一个东西，那生成器函数就是一个返回迭代器的函数 生成器函数从语法上来看，只是function关键字与函数名之间比普通函数多了一个星号，同时每一次迭代，都会通过 yield关键字来实现 我们把上面代码改写一下： 12345678910function *makeIterator(array) &#123; for (let i = 0; i &lt; array.length; i++) &#123; yield array[i] &#125;&#125;var it = makeIterator(['a', 'b'])it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 打印的值和上面代码是一模一样的，所以生成器的出现实际上是为了简化掉我们上面那一坨代码，简化创建迭代器的过程 咱们再来看个简单的栗子： 1234567function* helloWorldGenerator() &#123; yield 'hello' yield 'world' return 'ending'&#125;var hw = helloWorldGenerator() 上面代码定义了一个生成器函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）12345678hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 下一步，我们必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。我们可以理解为，生成器函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行 co 模块co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于生成器函数的自动执行 下面是一个生成器函数，用于依次读取两个文件，这里的 yield 关键字后面跟的是一个 Promise： 1234567891011121314151617var fs = require('fs')var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125;var gen = function* () &#123; var f1 = yield readFile('/etc/fstab') var f2 = yield readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125; co 模块可以让你不用编写 Generator 函数的执行器。 12var co = require('co')co(gen) 上面代码中，Generator 函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。 123co(gen).then(function ()&#123; console.log('Generator 函数执行完成')&#125;) 上面代码中，等到 Generator 函数执行结束，就会输出一行提示 为什么 co 可以自动执行 Generator 函数？简单的说就是将异步操作包装成 Promise 对象，用then方法交回执行权，具体细节大家可以去看 co 库的源码 4、Async/awaitES2017 标准引入了 async 函数，使得异步操作变得更加方便 async/await调用方式跟使用co库后的Generator函数看起来很相似，自带执行器，并且语义更清楚 1234567891011121314151617181920var fs = require('fs')var co = require('co')var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab') var f2 = yield readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125;co(gen) 写成 async 函数，就是下面这样： 12345678910111213141516171819var fs = require('fs')var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125;var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab') var f2 = await readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125;asyncReadFile() 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已 所以说，生成器函数和 co 库都只是 async/await 标准化落地之前的过度方案，现在我们只要掌握 Promise 和 async/await 即可 三、总结然后最后总结一下，今天我们探讨了 js 异步的实现已经 js 异步流程的演进路线，js 异步的实现，相信大家现在都能理解了，而 js 异步流程，从 promise 到 async 函数，无论如何，promise都是基石，是必须要掌握的，而生成器函数和 co 只是为了引出 async/await 的过度方案，所以大家只要掌握 promise 和 最终方案 async/await 即可","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"ECMAScript 6","date":"2018-08-26T23:16:56.000Z","path":"2018/08/27/ECMAScript 6/","text":"ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。阮一峰老师的ECMAScript 6 入门中详细介绍了ES6中最新的语法和修改。本篇博客作为学习记录，整理了一下ES6中常用的一些知识和特性。 let、const命令与块级作用域let命令基本用法123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 不存在变量提升1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // \"undefined\" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; const命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 块级作用域let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 对象新特性属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于const baz = &#123;foo: foo&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写。 12345678910111213const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; 属性名表达式123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 函数的新特性参数的默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello rest参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = n =&gt; n;// 等同于var f = function (n) &#123; return n;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 数组的解构赋值基本用法下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。对象中属性名和属性值相同时，可以 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 如果解构失败，变量的值等于undefined。 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 12let _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。 用途变量的解构赋值用途很多。 （1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\")","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"Redux入门指南","date":"2018-08-12T10:28:56.000Z","path":"2018/08/12/Redux入门指南/","text":"Demo1234为了方便讲解，我写了一个Demo，请先安装一下$ git clone https://github.com/GYunZhi/cnode.git$ cd cnode &amp;&amp; yarn$ yarn start 一、三大原则Redux 可以用这三个基本原则来描述： 单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。 1234567891011121314151617console.log(store.getState())/* 输出&#123; visibilityFilter: 'SHOW_ALL', todos: [ &#123; text: 'Consider using Redux', completed: true, &#125;, &#123; text: 'Keep all state in a single tree', completed: false &#125; ]&#125;*／ State 是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。 123456789store.dispatch(&#123; type: 'COMPLETE_TODO', index: 1&#125;)store.dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_COMPLETED'&#125;) 使用纯函数来执行修改为了描述 action 如何改变 state tree ，你需要编写 reducers。 Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。 1234567891011121314151617181920212223242526272829303132333435function visibilityFilter(state = 'SHOW_ALL', action) &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter default: return state &#125;&#125;function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, &#123; text: action.text, completed: false &#125; ] case 'COMPLETE_TODO': return state.map((todo, index) =&gt; &#123; if (index === action.index) &#123; return Object.assign(&#123;&#125;, todo, &#123; completed: true &#125;) &#125; return todo &#125;) default: return state &#125;&#125;import &#123; combineReducers, createStore &#125; from 'redux'let reducer = combineReducers(&#123; visibilityFilter, todos &#125;)let store = createStore(reducer) 就是这样，现在你应该明白 Redux 是怎么回事了。 二、基本概念redux中有三个基本概念，Action，Reducer，Store。 Action官方的介绍： Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch(). 中文： Actions 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。用法是通过 store.dispatch() 把 action 传到 store。 总结： Action 有两个作用。 用Action来分辨具体的执行动作。比如是create ?还是delete？或者是update？ 操作数据首先得有数据。比如添加数据得有数据，删除数据得有ID,action携带了这些数据。 Reducer官方的介绍： Actions describe the fact that something happened, but don’t specify how the application’s state changes in response. This is the job of a reducer. 中文： Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。这是 reducer 要做的事情。 总结： Action就像leader，告诉我们应该做哪些事，并且提供数据，真正干活的是苦逼的Reducer。 Store一个应用只有一个Store。一个应用只有一个Store。一个应用只有一个Store。 重要的事情放在前面说，而且说三遍。 官方的介绍： In the previous sections, we defined the actions that represent the facts about “what happened” and the reducers that update the state according to those actions. The Store is the object that brings them together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener). 翻译成中文： 上面章节中，我们学会了使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。 Store 就是把它们联系到一起的对象。Store 有以下职责： 保存应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器。 总结： Store提供了一些方法。让我们很方便的操作数据。 我们不用关心Reducer和Action是怎么关联在一起的，Store已经帮我们做了这些事 Redux 流程图 三、详细介绍这部分主要讲解redux如何在项目中使用。 ActionAction 是一个普通对象。 redux约定 Action 内使用一个字符串类型的 type 字段来表示将要执行的动作。 123&#123; type: 'ADD_ITEM'&#125; 除了 type 之外，Action可以存放一些其他的想要操作的数据。例如： 1234&#123; type: 'ADD_ITEM', text: '我是Berwin'&#125; 上面例子表示 我要创建一条数据 创建的数据为大概是这样的 123&#123; text: '我是Berwin'&#125; 但在实际应用中，我们需要一个函数来为我们创建Action。这个函数叫做actionCreator。它看起来是这样的： 123456function addItem(text) &#123; return &#123; type: types.ADD_ITEM, text &#125;&#125; ReducerReducer 是一个普通的回调函数，其函数签名为reducer(previousState, action)。 当它被Redux调用的时候会为他传递两个参数State 和 Action。 Reducer会根据 Action 的type来对旧的 State 进行操作,返回新的State。 看起来是下面这样的： 1234const action = &#123; type: 'ADD_TODO', text: 'Learn Redux'&#125;; Reducer很简单，但有三点需要注意 不要修改 state。 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。 如果没有旧的State，就返回一个initialState，这很重要！！！ 这是一部分核心源码： 12// currentState 是当前的State，currentReducer 是当前的ReducercurrentState = currentReducer(currentState, action); 如果在default或没有传入旧State的情况下不返回旧的State或initialState,那么当前的State会被重置为undefined！！ 在使用combineReducers方法时，它也会检测你的函数写的是否标准。如果不标准，那么会抛出一个大大的错误！！ combineReducers 真正开发项目的时候State会涉及很多功能，在一个Reducer处理所有逻辑会非常混乱，，所以需要拆分成多个小Reducer，每个Reducer只处理它管理的那部分State数据。然后在由一个主rootReducers来专门管理这些小Reducer。 Redux提供了一个方法 combineReducers 专门来管理这些小Reducer。 它看起来是下面这样： 12345678910111213141516171819202122232425/** * 这是一个子Reducer * @param State * @param Action * @return new State */let list = (state = [], action) =&gt; &#123; switch (action.type) &#123; case ADD_ITEM: return [createItem(action.text), ...state] default: return state &#125;&#125;// 这是一个简单版的子Reducer，它什么都没有做。let category = (state = &#123;&#125;, action) =&gt; state;/** * 这是一个主Reducer * @param State * @param Action * @return new State */let rootReducers = combineReducers(&#123;list, category&#125;); combineReducers 生成了一个类似于Reducer的函数。为什么是类似于，因为它不是真正的Reducer，它只是一个调用Reducer的函数，只不过它接收的参数与真正的Reducer一模一样~ 这是一部分核心源码： 1234567891011121314151617181920function combineReducers(reducers) &#123; // 过滤reducers，把非function类型的过滤掉 var finalReducers = pick(reducers, (val) =&gt; typeof val === 'function'); // 一开始我一直以为这个没啥用，后来我发现，这个函数太重要了。它在一开始，就已经把你的State改变了。变成了，Reducer的key 和 Reducer返回的initState组合。 var defaultState = mapValues(finalReducers, () =&gt; undefined); return function combination(state = defaultState, action) &#123; // finalReducers 是 reducers var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123; // state[key] 是当前Reducer所对应的State，可以理解为当前的State var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); return nextStateForKey; &#125;); // finalState 是 Reducer的key和stat的组合。。 &#125;&#125; 从上面的源码可以看出，combineReducers 生成一个类似于Reducer的函数combination。 当使用combination的时候，combination会把所有子Reducer都执行一遍，子Reducer通过action.type 匹配操作，因为是执行所有子Reducer，所以如果两个子Reducer匹配的action.type是一样的，那么都会成功匹配。 Store上面已经介绍什么是Store，以及它是干什么的，这里我就讲讲如何创建Store，以及如何使用Store的方法。 创建Store非常简单。createStore 有两个参数，Reducer 和 initialState。 1let store = createStore(rootReducers, initialState); store有四个方法。 getState： 获取应用当前State。 subscribe：添加一个变化监听器。 dispatch：分发 action。修改State。 replaceReducer：替换 store 当前用来处理 state 的 reducer。 常用的是dispatch，这是修改State的唯一途径，使用起来也非常简单，他看起来是这样的~ 1234567891011121314/** * 创建Action * @param 添加的数据 * @return &#123;Object&#125; Action */function addItem(text) &#123; return &#123; type: types.ADD_ITEM, text &#125;&#125;// 新增数据store.dispatch(addItem('Read the docs')); 这是一部分核心源码： 12345678910function dispatch(action) &#123; // currentReducer 是当前的Reducer currentState = currentReducer(currentState, action); listeners.slice().forEach(function (listener) &#123; return listener(); &#125;); return action;&#125; 可以看到其实就是把当前的Reducer执行了。并且传入State和Action。 State哪来的？ State其实一直在Redux内部保存着。并且每次执行currentReducer都会更新。在上面代码第一行可以看到。 四、React-ReduxRedux 是独立的，它与React没有任何关系。React-Redux是官方提供的一个库，用来结合redux和react的模块。 React-Redux提供了两个接口Provider、connect。 ProviderProvider是一个React组件，它的作用是保存store给子组件中的connect使用。 通过getChildContext方法把store保存到context里。 后面connect中会通过context读取store。 它看起来是这个样子的： 123&lt;Provider store=&#123;this.props.store&#125;&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/Provider&gt; 这是一部分核心源码： 12345678getChildContext() &#123; return &#123; store: this.store &#125;&#125;constructor(props, context) &#123; super(props, context) this.store = props.store&#125; 可以看到，先获取store，然后用 getChildContext 把store保存起来~ connectconnect 会把State和dispatch转换成props传递给子组件。它看起来是下面这样的： 123456789101112import * as actionCreators from './actionCreators'import &#123; bindActionCreators &#125; from 'redux'function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(Component) 它会让我们传递一些参数：mapStateToProps，mapDispatchToProps，mergeProps（可不填）和React组件。 之后这个方法会进行一系列的黑魔法，把state，dispatch转换成props传到React组件上，返回给我们使用。 mapStateToProps： mapStateToProps 是一个普通的函数。 当它被connect调用的时候会为它传递一个参数State。 mapStateToProps需要负责的事情就是 返回需要传递给子组件的State，返回需要传递给子组件的State，返回需要传递给子组件的State，（重要的事情说三遍。。。。）然后connect会拿到返回的数据写入到react组件中，然后组件中就可以通过props读取数据啦~~~~ 它看起来是这样的： 123function mapStateToProps(state) &#123; return &#123; list: state.list &#125;&#125; 因为stat是全局State，里面包含整个项目的所有State，但是我不需要拿到所有State，我只拿到我需要的那部分State即可，所以需要返回 state.list 传递给组件 mapDispatchToProps： 与mapStateToProps很像，mapDispatchToProps也是一个普通的函数。 当它被connect调用的时候会为它传递一个参数dispatch。 mapDispatchToProps负责返回一个 dispatchProps dispatchProps 是actionCreator的key和dispatch(action)的组合。 dispatchProps 看起来长这样： 123&#123; addItem: (text) =&gt; dispatch(action)&#125; connect 收到这样的数据后，会把它放到React组件上。然后子组件就可以通过props拿到addItem并且使用啦。 1this.props.addItem('Hello World~'); 如果觉得复杂，不好理解，，那我用大白话描述一下 就是通过mapDispatchToProps这个方法，把actionCreator变成方法赋值到props，每当调用这个方法，就会更新State。。。。额，，这么说应该好理解了。。 bindActionCreators： 但如果我有很多个Action，总不能手动一个一个加。Redux提供了一个方法叫 bindActionCreators。 bindActionCreators 的作用就是将 Actions 和 dispatch 组合起来生成 mapDispatchToProps 需要生成的内容。 它看起来像这样： 12345678let actions = &#123; addItem: (text) =&gt; &#123; type: types.ADD_ITEM, text &#125;&#125;bindActionCreators(actions, dispatch); // @return &#123;addItem: (text) =&gt; dispatch(&#123; type: types.ADD_ITEM, text &#125;)&#125; 这是一部分核心源码： 1234567891011121314151617function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args));&#125;// mapValues： map第一个参数的每一项，返回对象，key是key，value是第二个参数返回的数据/* * mapValues： map第一个参数的每一项，返回对象，key是key，value是第二个参数返回的数据 * @param actionCreators * @param dispatch * @return &#123;actionKey: (...args) =&gt; dispatch(actionCreator(...args))&#125; */export default function bindActionCreators(actionCreators, dispatch) &#123; return mapValues(actionCreators, actionCreator =&gt; bindActionCreator(actionCreator, dispatch) );&#125; 可以看到，bindActionCreators 执行这个方法之后，它把 actionCreators 的每一项的 key 不变，value 变成 dispatch(actionCreator(...args)) 这玩意，这表示，actionCreator 已经变成了一个可执行的方法，执行这个方法，就会执行 dispatch 更新数据。。 加了React-Redux之后的流程图","tags":[{"name":"React","slug":"React","permalink":"https://gyunzhi.github.io/tags/React/"}]},{"title":"跨文档消息通信","date":"2018-08-05T10:28:56.000Z","path":"2018/08/05/跨文档消息通信/","text":"在开发过程中我们会使用ifram来嵌入一个页面或者通过window.open打开一个新的窗口，这两个窗口之间有时候需要通信，下面我们看下具体会有哪些情况。 不同窗口之间通信有两种情况： ifram 与通过ifram标签打开的窗口通信 window.open 与window.open打开的窗口通信 这两种情况又分为了同域下的窗口通信和不同域下的通信 同域下的窗口通信ifram12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;// 通过js可以访问被包含页面的DOM元素window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyIframe = document.getElementById('myframe'); oBtn.onclick = function() &#123; // 如果我们要操作一个iframe里面的dom元素，需要通过 contentWindow 获取到iframe引入的页面的window对象 oMyIframe.contentWindow.document.body.style.background = 'red'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，改变2.iframe.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"2.iframe.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); /* window : 当前窗口 parent : 父级窗口 top : 顶级窗口 */ oBtn.onclick = function() &#123; //parent =&gt; window 如果当前页面是顶级，没有被其他页面所包含，那么parent就是当前页面的window对象，那么如果被包含了，则parent就是包含当前页面的父级页面的window对象 parent.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这里是2.iframe.html页面 &lt;input type=\"button\" value=\"点击我，改变1.iframe.html的背景色\" id=\"btn\" /&gt;&lt;/body&gt;&lt;/html&gt; window.open1234567891011121314151617181920212223242526272829&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oBtn2 = document.getElementById('btn2'); var newWindow = null; oBtn.onclick = function() &#123; //window.open 返回被打开窗口的window对象 newWindow = window.open('2.window.open.html', '_blank'); &#125; oBtn2.onclick = function() &#123; newWindow.document.body.style.background = 'red'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，开启一个新的窗口打开2.window.open.html页面\" id=\"btn\" /&gt; &lt;input type=\"button\" value=\"点击我，改变2.window.open.html页面的背景色\" id=\"btn2\" /&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //window.opener : 通过window.open方法打开当前页面的窗口的window对象 window.opener.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是4.window.open.html页面 &lt;input type=\"button\" value=\"点击我，改变1.window.open.html页面的背景色\" id=\"btn\" /&gt;&lt;/body&gt;&lt;/html&gt; 不同域下的窗口通信（跨文档通信）问题：跨域之后之前同域下的操作都失效了，会产生跨域安全限制问题 解决：postMessage方法，通过这个方法给另外一个窗口发送信息 （注意：接收消息的窗口的window对象调用postMessage方法） a域名12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn') var oMyIframe = document.getElementById('myframe') /* postMessage : 可以通过这个方法给另外一个窗口发送信息 注意：接收消息的窗口的window对象调用postMessage方法 */ oBtn.onclick = function() &#123; /* 第一个参数：发送的数据 第二个参数：接收数据的域名｛带上协议｝ */ oMyIframe.contentWindow.postMessage('1', 'http://www.b.com') &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，www.b.com域名下postMessage.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"http://www.b.com/postMessage.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; b域名12345678910111213141516171819202122232425262728&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; // message事件 : 当窗口接收到通过postMessage发送过来的数据的时候触发 window.addEventListener('message', function(ev) &#123; /* message事件的事件对象下保存了发送过来的内容 ev.data: 发送过来的数据 ev.origin: 发送消息的域名 */ if (ev.data == '1') &#123; document.body.style.background = 'red'; &#125; &#125;, false);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是b.com的postMessage.html页面&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"事件探究","date":"2018-07-21T12:16:56.000Z","path":"2018/07/21/事件探究/","text":"概述事件是异步编程的一种实现，事件机制是对观察者模式（有时被称作发布/订阅模式 ）的进一步抽象。观察者(Observer)相当于事件监听者，被观察者(Observable)或者说主题(Subject)相当于事件源和事件，事件发生时通知事件监听者，执行相应的回调函数。 事件监听机制主要由事件源、事件对象、事件监听器三个部分组成： 事件源： 点击一个button，触发click事件，这个button就是事件源 事件对象：事件发生以后，会产生一个事件对象，作为参数传给监听函数 ，里面保存了和当前这个事件有关的一些详细信息 事件监听器：用来注册、监听和触发事件，操作部署在EventTarget接口 EventTarget接口DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 1注意: Internet Explorer 6-8 并不支持这个方法，而是提供了类似的 `element.attachEvent` API 。如果要进行跨浏览器使用，请考虑使用有效的JavaScript 库。 该接口主要提供三个实例方法。 addEventListener：绑定事件的监听函数 removeEventListener：移除事件的监听函数 dispatchEvent：触发事件 （1）addEventListener EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。 1target.addEventListener(type, listener[, useCapture]); 该方法接受三个参数。 type：事件名称，大小写敏感。 listener：监听函数。事件发生时，会调用该监听函数。 useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文事件流部分），默认为false（监听函数只在冒泡阶段被触发），该参数可选。 下面是一个例子。 123456function hello() &#123; console.log('Hello world');&#125;var button = document.getElementById('btn');button.addEventListener('click', hello, false); 上面代码中，button节点的addEventListener方法绑定click事件的监听函数hello，该函数只在冒泡阶段触发。 关于参数，有两个地方需要注意。 首先，第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。 12345buttonElement.addEventListener('click', &#123; handleEvent: function (event) &#123; console.log('click'); &#125;&#125;); 上面代码中，addEventListener方法的第二个参数，就是一个具有handleEvent方法的对象。 其次，第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。 capture：布尔值，表示该事件是否在捕获阶段触发监听函数。 once：布尔值，表示监听函数是否只触发一次，然后就自动移除。 passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。 如果希望事件监听函数只执行一次，可以打开属性配置对象的once属性。 123element.addEventListener('click', function (event) &#123; // 只执行一次的代码&#125;, &#123;once: true&#125;); addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用removeEventListener方法手动去除）。 123456function hello() &#123; console.log('Hello world');&#125;document.addEventListener('click', hello, false);document.addEventListener('click', hello, false); 执行上面代码，点击文档只会输出一行Hello world。 如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。 123456function print(x) &#123; console.log(x);&#125;var el = document.getElementById('div1');el.addEventListener('click', function () &#123; print('Hello'); &#125;, false); 上面代码通过匿名函数，向监听函数print传递了一个参数，如果不使用匿名函数包装，print会直接执行。 （2）removeEventListener EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。 12div.addEventListener('click', listener, false);div.removeEventListener('click', listener, false); removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。 注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。 12div.addEventListener('click', function (e) &#123;&#125;, false);div.removeEventListener('click', function (e) &#123;&#125;, false); 上面代码中，removeEventListener方法无效，因为监听函数不是同一个匿名函数。 12element.addEventListener('mousedown', handleMouseDown, true);element.removeEventListener(\"mousedown\", handleMouseDown, false); 上面代码中，removeEventListener方法也是无效的，因为第三个参数不一样。 （3）dispatchEvent EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。 1target.dispatchEvent(event) dispatchEvent方法的参数是一个Event对象的实例（参见后文Event对象部分）。 1234var el = document.getElementById('el')el.addEventListener('click', hello, false);var event = new Event('click');el.dispatchEvent(event); 上面代码在当前节点触发了click事件。 如果dispatchEvent方法的参数为空，或者不是一个有效的事件对象，将报错。 Event对象事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。 Event对象本身就是一个构造函数，可以用来生成新的实例。 1event = new Event(type, options); Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。 bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。 cancelable：布尔值，可选，默认为false，表示是否可以通过Event.preventDefault()方法取消浏览器对该事件的默认行为。 12345678var ev = new Event( 'look', &#123; 'bubbles': true, 'cancelable': false &#125;);document.dispatchEvent(ev); 上面代码新建一个look事件实例，然后使用dispatchEvent方法触发该事件。 注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。 1234567891011121314// HTML 代码为// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;var div = document.querySelector('div');var p = document.querySelector('p');function callback(event) &#123; var tag = event.currentTarget.tagName; console.log('Tag: ' + tag); // 没有任何输出&#125;div.addEventListener('click', callback, false);var click = new Event('click');p.dispatchEvent(click); 上面代码中，p元素发出一个click事件，该事件默认不会冒泡。div.addEventListener方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成div.addEventListener(&#39;click&#39;, callback, true)，那么在“捕获阶段”可以监听到这个事件。 实例属性Event.bubbles，Event.eventPhase Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。 Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。 1var phase = event.eventPhase; Event.eventPhase的返回值有四种可能。 0，事件目前没有发生。 1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。 2，事件到达目标节点，即Event.target属性指向的那个节点。 3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。 Event.cancelable，Event.cancelBubble，event.defaultPrevented Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。 大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。 12var evt = new Event('foo');evt.cancelable // false 当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。 如果事件不能取消，调用Event.preventDefault()会没有任何效果。所以使用这个方法之前，最好用Event.cancelable属性判断一下是否可以取消。 12345678function preventEvent(event) &#123; if (event.cancelable) &#123; event.preventDefault(); &#125; else &#123; console.warn('This event couldn\\'t be canceled.'); console.dir(event); &#125;&#125; Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。 Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。 123if (event.defaultPrevented) &#123; console.log('该事件已经取消了');&#125; Event.currentTarget，Event.target Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。 Event.target属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的Event.target与Event.currentTarget属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。 123456789// HTML代码为// &lt;p id=\"para\"&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;function hide(e) &#123; console.log(this === e.currentTarget); // 总是 true console.log(this === e.target); // 有可能不是 true e.target.style.visibility = 'hidden';&#125;para.addEventListener('click', hide, false); 上面代码中，如果在para节点的&lt;em&gt;子节点上面点击，则e.target指向&lt;em&gt;子节点，导致&lt;em&gt;子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个para都将不可见。 Event.type Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。 12var evt = new Event('foo');evt.type // \"foo\" Event.timeStamp Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。 12var evt = new Event('foo');evt.timeStamp // 3683.6999999995896 它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。 下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。 12345678910111213141516171819202122var previousX;var previousY;var previousT;window.addEventListener('mousemove', function(event) &#123; if ( previousX !== undefined &amp;&amp; previousY !== undefined &amp;&amp; previousT !== undefined ) &#123; var deltaX = event.screenX - previousX; var deltaY = event.screenY - previousY; var deltaD = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2)); var deltaT = event.timeStamp - previousT; console.log(deltaD / deltaT * 1000); &#125; previousX = event.screenX; previousY = event.screenY; previousT = event.timeStamp;&#125;); Event.isTrusted Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个click事件，该事件是用户产生的；Event构造函数生成的事件，则是脚本产生的。 12var evt = new Event('foo');evt.isTrusted // false 上面代码中，evt对象是脚本产生的，所以isTrusted属性返回false。 Event.detail Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于click和dbclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。 1234567// HTML 代码如下// &lt;p&gt;Hello&lt;/p&gt;function giveDetails(e) &#123; console.log(e.detail);&#125;document.querySelector('p').onclick = giveDetails; 实例方法Event.preventDefault() Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的cancelable属性为true，如果为false，调用该方法没有任何效果。 注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用stopPropagation()或stopImmediatePropagation()方法。 123456789// HTML 代码为// &lt;input type=\"checkbox\" id=\"my-checkbox\" /&gt;var cb = document.getElementById('my-checkbox');cb.addEventListener( 'click', function (e)&#123; e.preventDefault(); &#125;, false); 上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。 利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。 12345678910// HTML 代码为// &lt;input type=\"text\" id=\"my-input\" /&gt;var input = document.getElementById('my-input');input.addEventListener('keypress', checkName, false);function checkName(e) &#123; if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123; e.preventDefault(); &#125;&#125; 上面代码为文本框的keypress事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。 Event.stopPropagation() stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。 12345function stopEvent(e) &#123; e.stopPropagation();&#125;el.addEventListener('click', stopEvent, false); 上面代码中，click事件将不会进一步冒泡到el节点的父节点。 Event.stopImmediatePropagation() Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。 如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了Event.stopImmediatePropagation方法，其他的监听函数就不会再执行了。 12345678910function l1(e)&#123; e.stopImmediatePropagation();&#125;function l2(e)&#123; console.log('hello world');&#125;el.addEventListener('click', l1, false);el.addEventListener('click', l2, false); 上面代码在el节点上，为click事件添加了两个监听函数l1和l2。由于l1调用了event.stopImmediatePropagation方法，所以l2不会被调用。 Event.composedPath() Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。 1234567891011// HTML 代码如下// &lt;div&gt;// &lt;p&gt;Hello&lt;/p&gt;// &lt;/div&gt;var div = document.querySelector('div');var p = document.querySelector('p');div.addEventListener('click', function (e) &#123; console.log(e.composedPath());&#125;, false);// [p, div, body, html, document, Window] 上面代码中，click事件的最底层节点是p，向上依次是div、body、html、document、Window。 自定义事件下面是一个代码代码示例演示如何派发一个自定义的事件： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a id='el' href=\"javascript:;\"&gt;click&lt;/a&gt;&lt;/body&gt;&lt;script&gt; function fn(ev) &#123; // 事件对象可以是通过事件函数的第一个参数传入也可以是全局的event对象 console.log(event) console.log(ev) &#125; var el= document.getElementById('el') if (el.addEventListener) &#123; el.addEventListener('click', fn, false) &#125; else &#123; el.attachEvent('onclick', fn) &#125; var event = new Event('click', &#123;cancelable: false&#125;); el.dispatchEvent(event) // IE下触发click事件 // el.click()&lt;/script&gt;&lt;/html&gt; 绑定事件监听函数JavaScript 有三种方法，可以为事件绑定监听函数。 HTML 的 on- 属性 HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。 12&lt;body onload=\"doSomething()\"&gt;&lt;div onclick=\"console.log('触发事件')\"&gt; 上面代码为body节点的load事件、div节点的click事件，指定了监听代码。一旦事件发生，就会执行这段代码。 元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。 注意，这些属性的值是将会执行的代码，而不是一个函数。 12345&lt;!-- 正确 --&gt;&lt;body onload=\"doSomething()\"&gt;&lt;!-- 错误 --&gt;&lt;body onload=\"doSomething\"&gt; 一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。 直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。 123el.setAttribute('onclick', 'doSomething()');// 等同于// &lt;Element onclick=\"doSomething()\"&gt; 元素节点的事件属性 元素节点对象的事件属性，同样可以指定监听函数。这些事件属性由GlobalEventHandlers接口提供 。 1234window.onload = doSomething;div.onclick = function (event) &#123; console.log('触发事件');&#125;; 使用这个方法指定的监听函数的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段） EventTarget.addEventListener 所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。 1window.addEventListener('load', doSomething, false); addEventListener方法的详细介绍，参见上文EventTarget接口。 小结 上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。 第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。 第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点： 同一个事件可以添加多个监听函数。 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。 除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。 事件监听函数this指向监听函数内部的this指向触发事件的那个元素节点。 1&lt;button id=\"btn\" onclick=\"console.log(this.id)\"&gt;点击&lt;/button&gt; 执行上面代码，点击后会输出btn。 其他两种监听函数的写法，this的指向也是如此。 1234567891011121314151617// HTML 代码如下// &lt;button id=\"btn\"&gt;点击&lt;/button&gt;var btn = document.getElementById('btn');// 写法一btn.onclick = function () &#123; console.log(this.id);&#125;;// 写法二btn.addEventListener( 'click', function (e) &#123; console.log(this.id); &#125;, false); 上面两种写法，点击按钮以后也是输出btn。 事件流事件流描述的是页面中节点元素接收到事件的顺序，有意思的时早期IE和NetScape提出了两种相反的事件流的概念，IE提出的是事件冒泡流，而NetScape提出的是事件捕获流。在最新的规范出来之后，一般采用的是标准的DOM事件流。 从上图我们可以知道： 事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点 事件捕获：事件开始时由不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件 DOM事件流：包含3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段 ，默认是在冒泡阶段去执行监听函数 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 。可以防止事件处理程序过多，提高页面性能。事件委托还有一个好处就是动态添加进来的元素也能绑定事件处理函数 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;// 把li的事件处理函数放到ul上window.onload = function()&#123; var ul = document.getElementById(\"ul\"); ul.onclick = function()&#123; console.log(123) &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"Blob API的使用","date":"2018-07-15T20:16:56.000Z","path":"2018/07/16/Blob API的使用/","text":"在一般的Web开发中，很少会用到Blob，但Blob可以满足一些场景下的特殊需求。Blob，Binary Large Object的缩写，代表二进制类型的大对象。Blob的概念在一些数据库中有使用到，例如，MSQL中的BLOB类型就表示二进制数据的容器。在Web中，Blob类型的对象表示不可变的类似文件对象的原始数据，通俗点说，就是Blob对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作File对象一样操作Blob对象，实际上，File继承自Blob。 Blob基本用法创建Blob对象可以通过Blob的构造函数创建Blob对象： 1Blob(blobParts[, options]) 参数说明： blobParts：数组类型，数组中的每一项连接起来构成Blob对象的数据，数组中的每项元素可以是ArrayBuffer, ArrayBufferView, Blob, DOMString 。 options：可选项，字典格式类型，可以指定如下两个属性： type，默认值为 &quot;&quot;，它代表了将会被放入到blob中的数组内容的MIME类型。 endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： 1\"native\"，表示行结束符会被更改为适合宿主操作系统文件系统的换行符； 1\"transparent\"，表示会保持blob中保存的结束符不变。 例如： 123456789101112131415161718var data1 = \"a\";var data2 = \"b\";var data3 = \"&lt;div style='color:red;'&gt;This is a blob&lt;/div&gt;\";var data4 = &#123; \"name\": \"abc\" &#125;;var blob1 = new Blob([data1]);var blob2 = new Blob([data1, data2]);var blob3 = new Blob([data3]);var blob4 = new Blob([JSON.stringify(data4)]);var blob5 = new Blob([data4]);var blob6 = new Blob([data3, data4]);console.log(blob1); //输出：Blob &#123;size: 1, type: \"\"&#125;console.log(blob2); //输出：Blob &#123;size: 2, type: \"\"&#125;console.log(blob3); //输出：Blob &#123;size: 44, type: \"\"&#125;console.log(blob4); //输出：Blob &#123;size: 14, type: \"\"&#125;console.log(blob5); //输出：Blob &#123;size: 15, type: \"\"&#125;console.log(blob6); //输出：Blob &#123;size: 59, type: \"\"&#125; size代表Blob 对象中所包含数据的字节数。这里要注意，使用字符串和普通对象创建Blob时的不同，blob4使用通过JSON.stringify把data4对象转换成json字符串，blob5则直接使用data4创建，两个对象的size分别为14和15。blob4的size等于14很容易理解，因为JSON.stringify(data4)的结果为：&quot;{&quot;name&quot;:&quot;abc&quot;}&quot;，正好14个字节(不包含最外层的引号)。blob5的size等于15是如何计算而来的呢？实际上，当使用普通对象创建Blob对象时，相当于调用了普通对象的toString()方法得到字符串数据，然后再创建Blob对象。所以，blob5保存的数据是&quot;[object Object]&quot;，是15个字节(不包含最外层的引号)。 slice方法Blob对象有一个slice方法，返回一个新的 Blob对象，包含了源 Blob对象中指定范围内的数据。 1slice([start[, end[, contentType]]]) 参数说明： start： 可选，代表 Blob 里的下标，表示第一个会被会被拷贝进新的 Blob 的字节的起始位置。如果传入的是一个负数，那么这个偏移量将会从数据的末尾从后到前开始计算。 end： 可选，代表的是 Blob 的一个下标，这个下标-1的对应的字节将会是被拷贝进新的Blob 的最后一个字节。如果你传入了一个负数，那么这个偏移量将会从数据的末尾从后到前开始计算。 contentType： 可选，给新的 Blob 赋予一个新的文档类型。这将会把它的 type 属性设为被传入的值。它的默认值是一个空的字符串。 例如： 123456var data = \"abcdef\";var blob1 = new Blob([data]);var blob2 = blob1.slice(0,3);console.log(blob1); //输出：Blob &#123;size: 6, type: \"\"&#125;console.log(blob2); //输出：Blob &#123;size: 3, type: \"\"&#125; 通过slice方法，从blob1中创建出一个新的blob对象，size等于3。 Blob使用场景分片上传前面已经说过，File继承自Blob，因此我们可以调用slice方法对大文件进行分片长传。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738function uploadFile(file) &#123; var chunkSize = 1024 * 1024; // 每片1M大小 var totalSize = file.size; var chunkQuantity = Math.ceil(totalSize/chunkSize); //分片总数 var offset = 0; // 偏移量 var reader = new FileReader(); reader.onload = function(e) &#123; var xhr = new XMLHttpRequest(); xhr.open(\"POST\",\"http://xxxx/upload?fileName=\"+file.name); xhr.overrideMimeType(\"application/octet-stream\"); xhr.onreadystatechange = function() &#123; if(xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123; ++offset; if(offset === chunkQuantity) &#123; alert(\"上传完成\"); &#125; else if(offset === chunkQuantity-1)&#123; blob = file.slice(offset*chunkSize, totalSize); // 上传最后一片 reader.readAsBinaryString(blob); &#125; else &#123; blob = file.slice(offset*chunkSize, (offset+1)*chunkSize); reader.readAsBinaryString(blob); &#125; &#125;else &#123; alert(\"上传出错\"); &#125; &#125; if(xhr.sendAsBinary) &#123; xhr.sendAsBinary(e.target.result); // e.target.result是此次读取的分片二进制数据 &#125; else &#123; xhr.send(e.target.result); &#125; &#125; var blob = file.slice(0, chunkSize); reader.readAsBinaryString(blob);&#125; 这段代码还可以进一步丰富，比如显示当前的上传进度，使用多个XMLHttpRequest对象并行上传对象（需要传递分片数据的位置参数给服务器端）等。 Blob URLBlob URL是blob协议的URL，它的格式如下： 1blob:http://XXX Blob URL可以通过URL.createObjectURL(blob)创建。在绝大部分场景下，我们可以像使用Http协议的URL一样，使用Blob URL。常见的场景有：作为文件的下载地址和作为图片资源地址。 文件下载地址 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Blob Test&lt;/title&gt; &lt;script&gt; function createDownloadFile() &#123; var content = \"Blob Data\"; var blob = new Blob([content]); var link = document.getElementsByTagName(\"a\")[0]; link.download = \"file\"; link.href = URL.createObjectURL(blob); &#125; window.onload = createDownloadFile; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a&gt;下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 点击下载按钮，浏览器将会下载一个名为file的文件，文件的内容是：Blob Data。通过Blob对象，我们在前端代码中就可以动态生成文件，提供给浏览器下载。打开Chrome浏览器调试窗口，在Elements标签下可以看到生成的Blob URL为： 图片资源地址 为图片文件创建一个Blob URL，赋值给标签： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Blob Test&lt;/title&gt; &lt;script&gt; function handleFile(e) &#123; var file = e.files[0]; var blob = URL.createObjectURL(file); var img = document.getElementsByTagName(\"img\")[0]; img.src = blob; img.onload = function(e) &#123; URL.revokeObjectURL(this.src); // 释放createObjectURL创建的对象## &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" accept=\"image/*\" onchange=\"handleFile(this)\" /&gt; &lt;br/&gt; &lt;img style=\"width:200px;height:200px\"&gt;&lt;/body&gt;&lt;/html&gt; input中选择的图片会在里显示出来，如图所示： 同时，可以在Network标签栏，发现这个Blob URL的请求信息： 这个请求信息和平时我们使用的Http URL获取图片几乎完全一样。我们还可以使用Data URL加载图片资源： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Blob Test&lt;/title&gt; &lt;script&gt; function handleFile(e) &#123; var file = e.files[0]; var fileReader = new FileReader(); var img = document.getElementsByTagName(\"img\")[0]; fileReader.onload = function(e) &#123; img.src = e.target.result; &#125; fileReader.readAsDataURL(file); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" accept=\"image/*\" onchange=\"handleFile(this)\" /&gt; &lt;br/&gt; &lt;img style=\"width:200px;height:200px\"&gt;&lt;/body&gt;&lt;/html&gt; FileReader的readAsDataURL生成一个Data URL，如图所示： Data URL对大家来说应该并不陌生，Web性能优化中有一项措施：把小图片用base64编码直接嵌入到HTML文件中，实际上就是利用了Data URL来获取嵌入的图片数据。 那么Blob URL和Data URL有什么区别呢？ Blob URL的长度一般比较短，但Data URL因为直接存储图片base64编码后的数据，往往很长，如上图所示，浏览器在显示Data URL时使用了省略号（…）。当显式大图片时，使用Blob URL能获取更好的可能性。 Blob URL可以方便的使用XMLHttpRequest获取源数据，例如： 123456789var blobUrl = URL.createObjectURL(new Blob(['Test'], &#123;type: 'text/plain'&#125;));var x = new XMLHttpRequest();// 如果设置x.responseType = 'blob'，将返回一个Blob对象，而不是文本:// x.responseType = 'blob';x.onload = function() &#123; alert(x.responseText); // 输出 Test&#125;;x.open('get', blobUrl);x.send(); 对于Data URL，并不是所有浏览器都支持通过XMLHttpRequest获取源数据的。 3.Blob URL 只能在当前应用内部使用，把Blob URL复制到浏览器的地址栏中，是无法获取数据的。Data URL相比之下，就有很好的移植性，你可以在任意浏览器中使用。 除了可以用作图片资源的网络地址，Blob URL也可以用作其他资源的网络地址，例如html文件、json文件等，为了保证浏览器能正确的解析Blob URL返回的文件类型，需要在创建Blob对象时指定相应的type： 123456789// 创建HTML文件的Blob URLvar data = \"&lt;div style='color:red;'&gt;This is a blob&lt;/div&gt;\";var blob = new Blob([data], &#123; type: 'text/html' &#125;);var blobURL = URL.createObjectURL(blob);// 创建JSON文件的Blob URLvar data = &#123; \"name\": \"abc\" &#125;;var blob = new Blob([JSON.stringify(data)], &#123; type: 'application/json' &#125;);var blobURL = URL.createObjectURL(blob);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"从HTML5拖放事件探究文件上传功能","date":"2018-07-14T22:16:56.000Z","path":"2018/07/15/从HTML5拖放事件探究文件上传功能/","text":"拖放事件HTML5为所有的HTML元素新增了一个draggable属性，表示元素是否允许拖动。默认情况下，图像、链接和文本是可以拖动的，文本只有在被选中的情况下才能拖动。 需要注意的是在ff下只加draggable=&quot;true&quot;还不能实现拖放，需要做一些处理，大多数浏览器会为正被拖动的元素创建一个半透明的副本，这个副本始终跟着光标移动。 元素拖放时会触发一系列的拖放事件 1234567891011121314151617181920（1）拖放元素事件：事件对象为被拖放的元素 ondragstart 拖放开始触发 ondragend 拖放结束触发 ondrag 拖放期间触发，连续触发(无论拖放元素放在有效目标还是无效目标，都会触发)（2）目标元素事件：事件对象为目标元素 ondragenter 拖放元素进入目标元素触发 ondragleave 拖放元素离开目标元素触发 ondragover 拖放元素进入目标元素和离开目标元素之间触发，连续触发 ondrop 在目标元素上释放鼠标时触发，要想触发drop事件就必须在dragover当中阻止默认事件（3）事件执行顺序： drop不触发的时候 dragstart &gt; drag &gt; dragenter &gt; dragover &gt; dragleave &gt; dragend drop触发的时候 在dragover中阻止默认事件 dragstart &gt; drag &gt; dragenter &gt; dragover &gt; drop &gt; dragend 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;拖放事件&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul li &#123; width: 100px; height: 40px; background: #ff0; margin-bottom: 8px; list-style: none; &#125; div &#123; width: 200px; height: 200px; background: #f00; margin: 100px 0 0 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt; window.onload = function () &#123; var oUl = document.getElementById('ul1'); var oDiv = document.getElementById('div1'); var oLi = oUl.getElementsByTagName('li')[0]; var i = 0; // 拖放元素事件 oLi.ondragstart = function () &#123; this.style.background = 'blue'; &#125; oLi.ondragend = function () &#123; this.style.background = 'yellow'; &#125; oLi.ondrag=function ()&#123; //连续触发 document.title=i++; &#125; // 目标元素事件,通过重写dragenter和dragleave方法来自定义目标元素背景颜色 oDiv.ondragenter=function ()&#123; this.style.background='green'; &#125; oDiv.ondragleave=function ()&#123; this.style.background='red'; &#125; // 要想触发drop事件就必须在dragover当中阻止默认事件 oDiv.ondragover = function () &#123; console.log(i); return false; &#125; // 在目标元素上释放鼠标时触发 oDiv.ondrop = function () &#123; this.style.background = '#000'; &#125; &#125;;&lt;/script&gt;&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li draggable=\"true\"&gt;拖放元素&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"div1\"&gt;目标元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决ff下不能拖放的问题要解决ff下不能拖放的问题，必须在ondragstart事件中设置dataTransfer对象的setData方法，dataTransfer对象是event对象下的一个属性，需要通过event对象访问 ，下文会详细说明dataTransfer对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ff下不能拖放的问题&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul li&#123;width: 100px;height: 40px;background: #ff0;margin-bottom:8px;list-style: none; &#125; div&#123;width: 100px;height: 100px;background: #f00;margin:300px 0 0 300px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt;window.onload=function ()&#123; var oUl=document.getElementById('ul1'); var oDiv=document.getElementById('div1'); var aLi=oUl.getElementsByTagName('li'); // 拖放元素事件 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].ondragstart=function (ev)&#123; ev.dataTransfer.setData('name','gongyz'); &#125; &#125; // 目标元素事件 oDiv.ondragover=function ()&#123; return false; // 要想触发ondrop事件，必须在onondragover中阻止默认事件 &#125; oDiv.ondrop=function (ev)&#123; console.log(ev.dataTransfer.getData('name')) &#125;&#125;&lt;/script&gt;&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li draggable=\"true\"&gt;a&lt;/li&gt; &lt;li draggable=\"true\"&gt;b&lt;/li&gt; &lt;li draggable=\"true\"&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DataTransfer 对象概述DataTransfer 对象用来保存，通过拖放动作，拖动到浏览器的数据。它可以保存一项或多项数据、一种或者多种数据类型。 这个对象在所有的拖放事件属性dataTransfer中都是可用的，但是不能单独创建，也就是说，在进行拖放操作的时候，会自动创建一个dataTransfer对象，这个对象作为拖放事件的事件对象的一个属性，保存了当前拖放操作的数据。 方法 setData(key,value) ：设置拖放时要传递的数据（拖放元素） getData(key)：获取拖放时传递的数据（目标元素） setDragImage(DOMElement image,x,y) ：使用自定义的图片作为拖放时副本 (该方法接收三个参数 指定的元素，坐标X，坐标Y) 属性 files：用来获取外部拖放进来的文件，返回一个类数组的FileList对象 拖放删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;拖放删除元素&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul li&#123;width: 100px;height: 30px;margin:8px;background: #ff0;&#125; div&#123;width: 200px;height: 200px;margin:100px 0 0 100px;background: #f00;&#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt;window.onload=function ()&#123; var oUl=document.getElementsByTagName('ul')[0]; var oDiv=document.getElementsByTagName('div')[0]; var aLi=oUl.getElementsByTagName('li'); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index=i; aLi[i].ondragstart=function (ev)&#123; ev.dataTransfer.setData('data',this.index); &#125; &#125; oDiv.ondragover=function ()&#123; return false;//要想触发ondrop事件，必须在onondragover中阻止默认事件 &#125; oDiv.ondrop=function (ev)&#123; // 拿到索引值后删除对应的元素 var _index=ev.dataTransfer.getData('data'); oUl.removeChild(aLi[_index]); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; &#125; &#125;&#125;&lt;/script&gt;&lt;body&gt; &lt;ul&gt; &lt;li draggable=\"true\"&gt;a&lt;/li&gt; &lt;li draggable=\"true\"&gt;b&lt;/li&gt; &lt;li draggable=\"true\"&gt;c&lt;/li&gt; &lt;li draggable=\"true\"&gt;d&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 自定义拖放副本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;dataTransfer对象详解&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul li&#123;width: 100px;height: 40px;background: #ff0;margin-bottom:8px;list-style: none; &#125; div&#123;width: 100px;height: 100px;background: #f00;margin:300px 0 0 300px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt;window.onload=function ()&#123; /* setDragImage方法 使用自定义的图片作为拖放时副本 该方法接收三个参数 指定的元素，坐标X，坐标Y */ var oUl=document.getElementById('ul1'); var oDiv=document.getElementById('div1'); var aLi=oUl.getElementsByTagName('li'); var oImg=document.getElementsByTagName('img')[0]; // 拖放元素事件 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index=i; aLi[i].ondragstart=function (ev)&#123; var ev=ev||event; this.style.background='blue'; ev.dataTransfer.setData('name','leo'); ev.dataTransfer.setDragImage(oImg,0,0) &#125; &#125; //目标元素 oDiv.ondragover=function ()&#123; return false; // 要想触发drop事件就必须在dragover当中阻止默认事件 &#125; oDiv.ondrop=function ()&#123; console.log(123) &#125;&#125;;&lt;/script&gt;&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li draggable=\"true\"&gt;a&lt;/li&gt; &lt;li draggable=\"true\"&gt;b&lt;/li&gt; &lt;li draggable=\"true\"&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;img src=\"xxx.png\"&gt;&lt;/body&gt;&lt;/html&gt; File和FileReader对象File是一个是特殊类型的Blob对象，保存了和文件有关的信息。File 对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以是来自由拖放操作生成的DataTransfer对象中的files属性，这个属性就是一个类数组的FileList对象。 FileReader 用来读取通过dataTransfer对象的files属性获取的外部文件 ，将文件读取为Data URL格式,读取的结果保存在result属性中，如果是图片，返回base64格式的图片数据 。 结合之前的拖放操作和DataTransfer对象，我们就可以实现拖放上传文件功能，下面的代码示例介绍了FileReader接口的使用方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片预览功能&lt;/title&gt; &lt;style type=\"text/css\"&gt; div&#123;width: 300px;height: 300px;background: #f00;margin:100px 0 0 200px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;script&gt;window.onload=function ()&#123; /* fileReader对象 用来读取通过dataTransfer对象的files属性获取的文件 var fd = new FileReader(); readAsDataURL()方法 参数为要读取的文件对象，将文件读取为DataURL格式 onload事件 当读取文件完成的时候触发此事件 fd.result 取读取的文件数据，如果是图片，返回base64格式的图片数据 */ var oDiv=document.getElementById('div1'); var oUl=document.getElementsByTagName('ul')[0]; //目标元素 oDiv.ondragover=function ()&#123; return false;// 要想触发drop事件就必须在dragover当中阻止默认事件 &#125; oDiv.ondrop=function (ev)&#123; var ev=ev||event; var fs=ev.dataTransfer.files; for (var i = 0; i &lt; fs.length; i++) &#123; if (fs[i].type.indexOf('image') !== -1) &#123; var fd=new FileReader(); fd.readAsDataURL(fs[i]); fd.onload=function ()&#123; var oLi=document.createElement('li'); oLi.innerHTML='&lt;img src=\"'+this.result+'\"&gt;'; oUl.appendChild(oLi); &#125; &#125;else&#123; alert('请上传图片类型！！！'); &#125; &#125; return false; &#125;&#125;;&lt;/script&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;请把文件拖放在此处&lt;/div&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"面向对象程序设计","date":"2018-07-07T21:16:56.000Z","path":"2018/07/08/面向对象程序设计/","text":"理解对象基本概念在学习面向对象开发之前，我觉的有必要先来了解对象这个东西是什么，ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员自定义的类型。 原生的引用类型有：Object、Array、Date、RegExp、Function，基本包装类型Boolean、Number、String以及两个单体内置对象Global（在浏览器环境window对象就是Global）、Math。 说明：Object、Array、…、String、Global、Math都是内置对象，ECMA-262对内置对象的定义是：“由ECMAScript提供的，不依赖于宿主环境的对象，这些对象在ECMAScript执行之前就已经存在了”，也就是说开发人员不需要显式的实例化内置对象，因为它们已经实例化了。那么单体内置对象又是什么意思呢。其实也很好理解，看一下下面的代码： 123456789// 在chromo控制台操作Objectƒ Object() &#123; [native code] &#125;Arrayƒ Array() &#123; [native code] &#125;MathMath &#123;abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …&#125; 我们可以看到Object、Array是函数，而Math是对象，所以可以直接使用Math的API，而其他的内置对象一般是作为构造函数，通过new关键字用来来创建一个对象的。 创建自定义对象最简单的方式就是创建一个Object实例，Object是所有对象的基础，也就是说Object类型所具有的属性和方法同样也存在于具体的对象中。（在后面的讲解原型链会做出具体说明） 123456var person = new Object()person.name='leo'person.sayName = function ()&#123; console.log('名字:'+this.name);&#125;person.sayName() // leo 上面的例子中，我们创建了一个person对象，并且给它添加了name属性和sayName方法，但现在有更简洁的写法，通过对象字面量形式来创建对象： 1234567var person = &#123; name: 'leo', showName: function () &#123; console.log(this.name); &#125;&#125;person.showName(); 对象的属性类型ECMAScript-262 的定义中，对象的属性有两种，一种是数据属性，另一种是访问器属性 ，这两种属性都有一些特性值来描述该属性。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。而且为了表示这些特性是内部值，该规范把它们放在了两对方括号中，例如[[Enumerable]]。 数据属性数据属性共有4个描述其行为的特性，其中包含一个存放数据值得特性。 1234567[[Configurable]]： 表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true。[[Enumerable]]： 表示能否通过for-in遍历属性。默认为true。[[Writable]]： 表示能否修改属性的值。默认为true。[[Value]]： 用于存放属性的数据值，默认为undefined。 要修改属性默认的特性，必须使用 ESMAScript 5 的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。 123456789let person = &#123; name: 'gongyz'&#125;Object.defineProperty(person, \"name\", &#123; writable: false, value: 'zhangsan'&#125;)person.name = '123'console.log(person) // 'zhangsan' 上面的代码创建了一个name属性，当我们调用Object.defineProperty()writable特性设为false后，如果为它指定新值，非严格模式下操作会被忽略，严格模式下，赋值操作将会抛出错误。 访问器属性访问器属性不包括数据值，但它包含一对getter和setter函数（不过这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责处理数据。访问器属性有如下4个特性。 [[Configurable]]：同上。 [[Enumerable]]：同上。 [[Get]]：在读取属性时调用的函数。默认为undefined。 [[Set]]：在写入属性时调用的函数。默认为undefined。 注意：访问器属性不能被直接定义，必须使用Object.defineProperty()方法 1234567891011121314151617181920// 访问器属性var book = &#123; _year: 2004, // _year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性 version: 1&#125;Object.defineProperty(book, 'year', &#123; get: function () &#123; return this._year &#125;, set: function (newVal) &#123; if (newVal &gt; 2004) &#123; this._year = newVal this.version += newVal - 2004 &#125; &#125;&#125;)book.year = 2008console.log(book) 上面的代码创建了一个book对象，并给它定义了两个默认属性；_year和version。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year包含一个getter和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此把year属性修改为2008会导致_year变成2008，而version变成5。这是访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。 注意：在IE8及之前的IE浏览器不支持Object.defineProperty()方法，要创建访问器属性，一般使用两个非标准的方法__defineGetter__ 和__defineSetter__。 1234567891011// 定义访问器属性的旧方法book.__defineGetter__(&apos;year&apos;, function () &#123; return this._year&#125;)book.__defineSetter__(&apos;year&apos;, function (newVal) &#123; if (newVal &gt; 2004) &#123; this._year = newVal this.version += newVal - 2004 &#125;&#125;) 定义多个属性ESMAScript 5 定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次性定义多个属性。这个方法接收两个对象参数：第一个是要添加和修改其属性的对象，第二个对象的属性与第一个对象要添加或修改的属性一 一对应。 123456789101112131415161718192021222324let book = &#123;&#125;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, version: &#123; value: 1 &#125;, year: &#123; get: function () &#123; return this._year &#125;, set: function (newVal) &#123; if (newVal &gt; 2004) &#123; this._year = newVal this.version += newVal - 2004 &#125; &#125; &#125;&#125;)book.year = 2008console.log(book)console.log(book.year) 读取属性的特性ESMAScript 5 的Object.getOwnPropertyDescriptor() 方法，可以获取给定属性的特性。同样的IE9+的浏览器支持此方法。 1Object.getOwnPropertyDescriptor(book, 'year') 创建对象工厂模式虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建多个对象，会产生大量重复代码。为了解决这个问题，同时考虑到在ECMAScript中无法创建类，开发人员就用封装函数来创建对象。这种通过用函数封装以特定接口创建对象的细节，并通过调用函数来创建对象的方式，称为工厂模式。 12345678910111213141516171819202122232425262728function createPerson(name, sex) &#123; //原料 var obj = new Object(); //加工 obj.name = name; obj.sex = sex; obj.showName = function () &#123; console.log('名字:' + this.name); &#125;; obj.showSex = function () &#123; console.log('性别:' + this.sex); &#125; //出厂 return obj;&#125;;var p1 = createPerson('leo', 'male');var p2 = createPerson('gongyz', 'male');p1.showName(); // leop2.showName(); // gongyzconsole.log(p1 instanceof Object); // trueconsole.log(p2 instanceof Object); // trueconsole.log(p1.showName === p2.showName) // false 函数createPerson()能够根据接收的参数来创建一个包含基本信息的person对象。可以多次调用这个函数，而每次它都会返回一个包含两个属性和两个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但是却没有解决对象识别问题（没有办法通过 instance 判断创建出来的对象是什么类型，因为它总是Object），随着JavaScript的发展，有一个新的模式出现了。 构造函数模式我们知道，像Object、Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而创建自定义对象类型的属性和方法。例如，我们可以使用构造函数模式将前面的例子重写如下： 12345678910111213141516171819202122232425262728293031function Person(name, sex) &#123; // 假想的系统内部的工作流程 // var this=new Object(); this.name = name; this.sex = sex; this.showName = function () &#123; console.log('名字:' + this.name); &#125;; this.showSex = function () &#123; console.log('性别:' + this.sex); &#125; // 假想的系统内部的工作流程 // return this;&#125;;var p1 = new Person('leo', 'male');var p2 = new Person('lili', 'female');p1.showName(); // leop2.showName(); // liliconsole.log(p1 instanceof Person); // trueconsole.log(p2 instanceof Person); // trueconsole.log(p1 instanceof Object); // trueconsole.log(p2 instanceof Object); // true 在上面的代码中，Person()函数取代了createPerson()函数，同时Person()中的代码与createPerson()还存在一下不同之处： 没有显示的创建对象 直接将属性和方法赋给了this对象 没有return语句 首字母大写（按照惯例，构造函数首字母应该大写） 使用new关键字调用构造函数来创建对象 其实，要创建Person的新实例，必须使用new操作符。使用new关键字调用构造函数时实际上会经历下面4个步骤： 创建一个新的对象 this指向这个新的对象 执行构造函数中的代码，为对象添加属性和方法 返回新对象 使用构造函数创建对象可以将它的实例标识为一种特定的类型，这样就解决了工厂模式中对象识别问题。上面代码中创建的对象p1、p2都是Person的实例，但同时也都是Object的实例，这是因为所有的对象都继承自Object（这个在后面的继承中会说明）。 1、将构造函数当做函数 构造函数与普通函数的唯一区别就在于调用它们的方式不同。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；如果不通过 new 操作符调用，那它就和普通的函数调用没什么区别。例如前面定义的Person函数可以通过下列的任何一种方式调用： 123456789101112// 当做构造函数使用var person = new Person('gongyz', 'male')person.showName() // gongyz// 当做普通函数使用var person = Person('gongyz', 'male')window.showName() // gongyz // 添加到window// 在另一个对象作用域中调用var obj = new Object()Person.call(obj,'gongyz', 'male')obj.showName() // gongyz 2、构造函数的问题 构造函数模式使用了new关键字，解决了对象识别问题，但是没有解决方法复用问题，每次创建一个实例的时候，方法就会在那个实例上重新创建一遍，好在，这个问题可以通过原型模式解决。 原型模式几乎所有的函数（除了一些内建函数）都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是用来存放所有实例共享的属性和方法。我们把这个对象称为原型对象。我们可以给内置对象的prototype添加属性和方法，但是不推荐这样做，这样可能会覆盖掉内置对象的属性或方法。拿上面的例子来说，我们可以把方法和属性都放到原型对象中。 12345678910111213141516171819202122function Person() &#123;&#125;Person.prototype.name = 'gongyz';Person.prototype.sex = 'male';Person.prototype.showName = function () &#123; console.log('名字:' + this.name);&#125;;Person.prototype.showSex = function () &#123; console.log('性别:' + this.sex);&#125;var p1 = new Person();var p2 = new Person();p1.showName(); // gonygzp2.showName(); // gongyzconsole.log(p1.showName == p2.showName) // true 组合使用构造函数和原型模式通常情况下，公用的属性和方法才会放在prototype上，所以我们一般使用构造模式 + 原型模式的混合方式来创建对象 ，这样每一个实例既可以有自己的属性和方法，同时也有了共有的属性和方法。 123456789101112131415161718192021function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;;Person.prototype.showName = function () &#123; console.log('名字:' + this.name);&#125;;Person.prototype.showSex = function () &#123; console.log('性别:' + this.sex);&#125;var p1 = new Person('leo', 'male');var p2 = new Person('lili', 'female');p1.showName();p1.showSex();p2.showName();p2.showSex(); this指向问题在JavaScript，this的指向是很多该开始接触这门语言的人比较头疼的问题，大部分情况下，函数的调用方式决定了this的值，但也有一些例外的情况，同时在严格模式和非严格模式下this的值也会有一些差别。 通常情况下： 函数通过 new 调用，this 绑定的是新创建的对象 函数在某个上下文对象中调用，this 绑定的是那个上下文对象 函数通过call、apply、bind调用，this 绑定的是指定的上下文对象 全局环境下调用，默认绑定的是window对象。如果在严格模式下，绑定到undefined。 this指向出问题的情况： 构造函数里面有定时器 构造函数里面有事件 12345678910111213141516171819202122232425262728293031// 构造函数里面有定时器function Person()&#123; this.n = 12 var _this = this setInterval(function () &#123; _this.show() console.log(this) // window &#125;, 1000)&#125;Person.prototype.show = function ()&#123; console.log(this.n)&#125;var person = new Person()// 构造函数里面有事件var oBtn = document.getElementsByTagName('input')[0]function Person()&#123; this.n = 12 var _this = this oBtn.onclick = function ()&#123; _this.show() console.log(this) // input &#125;&#125;Person.prototype.show = function ()&#123; console.log(this.n)&#125;var person = new Person() 上面两种情况下，this指向的分别是window和input对象，解决这个问题很简单，另外保存一份当前对象的this引用就可以了。 继承继承是复用代码的一种形式，子类通过继承父类的属性和方法达到代码复用的目的。 原型链在每个对象上面都有一个__proto__属性，可称为隐式原型 。这不是一个标准的属性，但是每个浏览器都支持。该隐式原型指向的是创建该对象的构造函数的原型对象。这样就保证了实例能够访问在构造函数的原型中定义的属性和方法。对象和原型对象之间通过__proto__就构成了一条原型链。原型链的最外层是Object.prototype ，因为Object是所有对象的基础。 拷贝继承父类 123456789101112function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.showName = function () &#123; console.log(this.name);&#125;Person.prototype.showSex = function () &#123; console.log(this.sex);&#125; 子类 123456789101112131415function Worker(name, sex, job) &#123; // 调用父级的构造函数继承属性 Person.call(this, name, sex); // this -&gt; new 出来的Worker对象 this.job = job; // Worker.prototype = Person.prototype // 直接把父类的引用给子类，会导致子类修改父类 // 通过原型来继承父级的方法 for (var i in Person.prototype) &#123; Worker.prototype[i] = Person.prototype[i]; &#125; Worker.prototype.showJob = function () &#123; console.log(this.job); &#125;;&#125; 通过在子类的构造函数中调用父类的构造函数，并且通过call方法修改this指向，可以继承父类的属性。接下来我们需要继承父类的方法，如果直接把父类构造函数的原型对象引用赋值给子类原型对象，可以实现继承父类的方法，但是这样会导致我们在修改子类原型对象的时候会影响到父类的原型对象，所以我们通过for-in来继承父类的方法。可以封装一个extend方法来进行拷贝操作。下面是一个简单的extend方法封装。感兴趣可以去看看JQuery中的extend方法。实现起来更加复杂。 12345function extend(obj1, obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr] &#125;&#125; 拷贝方法有一个很大的问题就是，如果父类中存在不可枚举的方法，那么通过for-in是无法继承的。 类式继承在JavaScript中其实没有类的概念的，类式继承是通过构造函数实现继承。 子类 123456789101112function Worker(name, sex, job) &#123; // 调用父级的构造函数继承属性 Person.call(this, name, sex); // this -&gt; new 出来的Worker对象 this.job = job;&#125;// 继承父级原型中的方法Worker.prototype = new Person()Worker.prototype.constructor = Worker; // 让constructor 指向 WorkerWorker.prototype.showJob = function () &#123; console.log(this.job);&#125; 对象中常用的属性和方法hasOwnProperty : 判断是否是对象自身下面的属性 12345var arr = []arr.num = 10Array.prototype.num2 = 20console.log( arr.hasOwnProperty('num') ) // trueconsole.log( arr.hasOwnProperty('num2') ) // false constructor : 查看对象的构造函数 1234function Person ()&#123;&#125;var person = new Person()console.log( a1.constructor ) // PersonPerson.prototype.constructor = Person // 每一个函数都会有的，都是自动生成的 instanceof : 对象与构造函数在原型链上是否有关系 123function Person()&#123;&#125;var person = new Person()console.log( person instanceof Object ) // true","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"Ajax基础和应用","date":"2018-06-30T18:16:52.000Z","path":"2018/07/01/Ajax基础和应用/","text":"Ajax原理和封装Ajax全称为 Asynchronous JavaScript and XML （异步JavaScript和XML） ，使用Ajax可以无需刷新页面即可从服务器获取到数据，带来更好的用户体验。Ajax技术的核心是XMLHttpRequest对象，虽然名字中含有XML，但Ajax通信与数据格式无关，从服务器获取的数据可以是XML格式，也可以是JSON格式。目前来说，我们一般使用JSON格式的数据。 表单的基本知识在介绍XMLHttpRequest对象之前，我们先来了解一下表单基本知识，在Ajax出现之前，网页通常使用表单提交数据，但是这种方式在提交数据时会刷新页面，用户体验不太好。 表单的数据提交有两种方式：get、post，这两种方式在提交数据时有一点区别 action : 数据提交的地址，默认是当前页面 method : 数据提交的方式，默认是get方式 get： 数据以查询字符串的方式传递到服务器（username=gongyz&amp;age=a123） post：数据放在请求体中传递到服务器 enctype : 提交的数据的编码格式，默认是application/x-www-form-urlencoded ​ application/x-www-form-urlencoded ​ multipart/form-data ​ text/plain get方式 1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"get.php\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"text\" name=\"age\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?phpheader('content-type:text/html;charset=\"utf-8\"');error_reporting(0);$username = $_GET['username'];$age = $_GET['age'];echo \"你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;\"; post方式 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"post.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"text\" name=\"age\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678&lt;?phpheader('content-type:text/html;charset=\"utf-8\"');error_reporting(0);$username = $_POST['username'];$age = $_POST['age'];echo \"你的名字：&#123;$username&#125;，年龄：&#123;$age&#125;\"; XMLHttpRequest对象下面的代码是简单的的XMLHttpRequest对象的使用方法，try/catch是用来兼容IE6和以前的版本。在XMLHttpRequest 2级中，该对象有了一些新的特性，而且现在开发人员也不会去兼容IE6和它之前的版本了，取而代之的是一些Ajax库，比较常用的像Jquery的ajax方法、axios等。 1234567891011121314151617181920var xhr = null;try &#123; xhr = new XMLHttpRequest();&#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; console.log(xhr.responseText) &#125; else &#123; console.log('Error：', xhr.status, xhr.statusText); &#125; &#125;&#125;xhr.open('get','getList.php',true);xhr.send(null); 12345&lt;?phpheader('content-type:text/html;charset=\"utf-8\"');error_reporting(0);$arr1 = array(1, 2, 3);echo json_encode($arr1); 下面会对XMLHttpRequest属性和一些新特性做一些说明，虽然不用原生的XMLHttpRequest进行开发，但了解这些东西对我们还是有帮助的。 XHR用法open方法 在使用XHR对象时，要调用的第一个方法是open方法，该方法接受三个参数 ​ 请求类型： get/post ​ 请求URL ​ 是否异步发送请求（一般默认为true，不会去阻塞下面代码的执行） 注意：调用open方法并不会发送请求，而是启动一个请求以备发送 send方法 send方法接收一个参数，即要作为请求主体发送的数据，调用send方法后，请求就会发送到服务器，在收到响应后，相应的数据会自动填充XHR对象的属性 responseText：作为响应主体被返回的文本 responseXML：如果响应的内容是XML数据，这个属性中将会保存包含响应数据的XML DOM文档，否则为null status：http状态码 statusText：http状态说明 readyState： 该属性标识请求/响应响应过程当前所处的状态，该属性有5个取值，该值改变时会触发onreadystatechange事件 ​ 0： 未初始化化。尚未调用open方法。 ​ 1： 启动。已经调用open方法，但尚未调用send方法 ​ 2： 发送。已经调用send方法，但尚未接收到响应 ​ 3： 接收。已经接收的部分数据 ​ 4：完成。已经接收到全部响应数据，并且可以在客户端使用 对于同步请求，可以等到请求完成在进行其他操作，但通常情况，我们使用的是异步请求，所以需要在onreadystatechange事件中监测每次状态变化后readyState值。所以我们只对readyState值为4的情况感兴趣。 注意：为了保证浏览器兼容性，应该在调用open方法之前指定onreadystatechange事件的处理函数（目前没碰上过这种兼容性问题，但是建议这样处理，可能该问题在低版本浏览器会出现） abort方法 调用该方法后，XHR对象会停止触发事件，而且也不允许再访问任何与响应有关的对象属性。在终止操作后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。 get、post区别和处理使用XHR对象发送get请求 123456789101112131415161718192021222324var xhr = null;try &#123; xhr = new XMLHttpRequest();&#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125; xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; console.log( xhr.responseText ); &#125; else &#123; console.log('Error：', xhr.status, xhr.statusText); &#125; &#125;&#125; /* 存在的问题 1.缓存 在url？后面连接一个随机数，时间戳 2.乱码 编码encodeURI*/xhr.open('get','test.php?username='+encodeURI('刘伟')+'&amp;age=30&amp;' + new Date().getTime(),true);xhr.send(); 使用XHR对象发送post请求 12345678910111213141516171819202122232425var xhr = null;try &#123; xhr = new XMLHttpRequest();&#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; console.log( xhr.responseText ); &#125; else &#123; console.log('Error：', xhr.status, xhr.statusText); &#125; &#125;&#125; // post方式，数据放在send()里面作为参数传递xhr.open('post','test.php',true); // 申明发送的数据类型xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');// post没有缓存问题,无需编码xhr.send('username=刘伟&amp;age=30'); XHR新特性FormData FormData对象用来创建于与表单格式相同的数据（用于通过XHR传输），使用了FormData之后，不需要设置请求头的content-type，XHR能够识别传入的数据类型是FormData实例，并配置适当的头部信息。 12345678910111213141516171819202122232425var xhr = null;try &#123; xhr = new XMLHttpRequest();&#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; console.log( xhr.responseText ); &#125; else &#123; console.log('Error：', xhr.status, xhr.statusText); &#125; &#125;&#125;// post方式，数据放在send()里面作为参数传递xhr.open('post','test.php',true); let data = new FormData()data.append('username', 'gongyz')data.append('age', '123')xhr.send(data); load事件：在接收到完整的响应数据时触发，可以替换上面的onreadystatechange事件 progress事件：可以用来制作精度条 ​ lengthComputable：表示进度信息是否可用 ​ loaded：已经上传的字节数 ​ total：总字节数 下面是一个Ajax上传文件的例子，我们通过这个例子来学习load和progress事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 &#123;width: 300px; height: 30px; border: 1px solid #000; position: relative;&#125;#div2 &#123;width: 0; height: 30px; background: #CCC;&#125;#div3 &#123;width: 300px; height: 30px; line-height: 30px; text-align: center; position: absolute; left: 0; top: 0;&#125;&lt;/style&gt;&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyFile = document.getElementById('myFile'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); oBtn.onclick = function() &#123; var xhr = new XMLHttpRequest(); xhr.onload = function() &#123; console.log('OK,上传完成'); &#125; xhr.upload.onprogress = function(ev) &#123; if (lengthComputable) &#123; var iScale = ev.loaded / ev.total; oDiv2.style.width = 300 * iScale + 'px'; oDiv3.innerHTML = iScale * 100 + '%'; &#125; &#125; xhr.open('post', 'post_file.php', true); xhr.setRequestHeader('X-Request-With', 'XMLHttpRequest'); var oFormData = new FormData(); oFormData.append('file', oMyFile.files[0]); xhr.send(oFormData); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" id=\"myFile\" /&gt;&lt;input type=\"button\" id=\"btn\" value=\"上传\" /&gt; &lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;div id=\"div3\"&gt;0%&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意，progress事件不是定义在xhr，而是定义在xhr.upload，因为这里需要区分下载和上传，下载也有一个progress事件 小结Ajax的基本知识基本上都在上面，新增的特性还有一些，感兴趣的可以去看JavaScript高级程序设计（目前是第三版）。补充一句，关于Ajax文件上传可以去看看大家可以去看看我之前的文章从 HTML5 拖放事件 探究文件上传功能和Blob API的使用，另外阮一峰老师也有一篇博客文件上传的渐进式增强，也推荐大家看一看。 Ajax跨域解决方案JSONP在XMLHttpRequest 2 级之前，JSONP是最常用的跨域解决方案，JSONP由两部分组成，回调函数和数据。回调函数是当响应来到是应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 下面是一个JSONP的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#q &#123;width: 300px; height: 30px; padding: 5px; border:1px solid #f90; font-size: 16px;&#125;#ul1 &#123;border:1px solid #f90; width: 310px; margin: 0;padding: 0; display: none;&#125;li a &#123; line-height: 30px; padding: 5px; text-decoration: none; color: black; display: block;&#125;li a:hover&#123; background: #f90; color: white; &#125;&lt;/style&gt;&lt;script&gt;function handleResponse (data) &#123; var oUl = document.getElementById('ul1'); var html = ''; if (data.s.length) &#123; oUl.style.display = 'block'; for (var i=0; i&lt;data.s.length; i++) &#123; html += '&lt;li&gt;&lt;a target=\"_blank\" href=\"http://www.baidu.com/s?wd='+data.s[i]+'\"&gt;'+ data.s[i] +'&lt;/a&gt;&lt;/li&gt;'; &#125; oUl.innerHTML = html; &#125; else &#123; oUl.style.display = 'none'; &#125; &#125;window.onload = function() &#123; var oQ = document.getElementById('q'); var oUl = document.getElementById('ul1'); oQ.onkeyup = function() &#123; if ( this.value != '' ) &#123; var oScript = document.createElement('script'); oScript.src = 'http://suggestion.baidu.com/su?wd='+this.value+'&amp;cb=handleResponse'; document.body.appendChild(oScript); &#125; else &#123; oUl.style.display = 'none'; &#125; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; CORS跨域资源共享是XMLHttpRequest 2级加入了W3C的规范中，目前大部分主流浏览器都支持，CORS的基本思想就是使用HTTP头部让浏览器和服务器进行沟通，从而决定跨域请求时成功还是失败。 当发送一个HTTP请求时，浏览器检测到这是一个跨域请求，会给该请求添加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给与响应。下面是一个Origin头部的示例： 1Origin: http://www.nczoline.net 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发出相同的原信息（如果是公共资源，可以回发’*’）。例如： 1Access-Control-Allow-Origin: http://www.nczoline.net 如果没有这个头部，或者有这个头部但是源信息不匹配，浏览器就会驳回请求。正常情况下浏览器会处理请求。 注意：对于跨域请求，cookie不会再客户端和服务端之前传递（为了安全） 代码实例 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; /* 实现跨域请求，还需要后端的相关配合才可以 XDomainRequest： XDomainRequest是在IE8和IE9上的 CORS 的实现，在IE10中被包含CORS的 XMLHttpRequest 取代了 */ var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; var xhr = new XMLHttpRequest(); xhr.onload = function() &#123; console.log(xhr.responseText) &#125; xhr.open('get', 'http://www.b.com/ajax.php', true); xhr.send(); // var xdr= new XDomainRequest(); // xdr.onload = function() &#123; // console.log(this.responseText); // &#125; // xdr.open('get', 'http://www.b.com/ajax.php', true); // xdr.send(); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"跨域请求\" id=\"btn\" /&gt;&lt;/body&gt;&lt;/html&gt; 123&lt;?phpheader('Access-Control-Allow-Origin: http://www.a.com');echo 'hello';","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"闭包的应用","date":"2018-06-29T18:16:52.000Z","path":"2018/06/30/闭包的应用/","text":"闭包的概念函数嵌套函数，内部函数可以引用外部函数的参数和变量,外部函数执行完了之后，其变量和参数也不会被垃圾回收机制收回 （注：在JavaScript高级程序设计中对闭包下的定义是：闭包是指有有权访问另一个函数作用域中的变量的函数，这两者并不冲突，我个人 更倾向于闭包是一种概念） 闭包的作用（1） 让变量长期驻扎在内存当中 1234567891011function fn1()&#123; var a=5; function fn2()&#123; console.log(a); &#125; return fn2;&#125;fn=fn1(); //fn1执行完后，变量a并没有被垃圾回收机制收回fn(); //在这里，还可以访问到fn1中的变量a （2） 避免全局变量的污染 1234567891011121314151617181920212223var a=1;// 普通函数function fn1()&#123; a++; console.log(a)&#125;fn1(); //2fn1(); //3console.log(a); //3 全局变量被改变 // 使用闭包之后的函数：通过闭包实现每次调用a累加,同时又不会改变全局变量function fn2()&#123; var a=1; return function fn3()&#123; a++; alert(a); &#125;&#125;fn=fn2();fn(); //2fn(); //3console.log(a); //1 全局变量不变 （3）让函数拥有私有成员 12345678910111213141516171819202122232425262728// 让函数拥有私有成员var fn1 = (function ()&#123; var a=1; // 特权函数 function fn2()&#123; a++; console.log(a) &#125; // 特权函数 function fn3()&#123; a++; console.log(a); &#125; return&#123; \"fn2\":fn2, \"fn3\":fn3 &#125;&#125;)();fn1.fn2(); //2fn1.fn3(); //2console.log(a);//undefinedfn2();//undefinedfn3();//undefined 闭包的应用（1）模仿块级作用域 1234567(function ()&#123; //块级作用域 var a = 10 console.log(a) // 10&#125;)();console.log(a) // a is not defined （2）在循环中直接找到对应元素的索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;闭包2&lt;/title&gt; &lt;style type=\"text/css\"&gt; li&#123;background: #000;border:2px solid #fff;color: #fff;list-style: none;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;script&gt;// 普通函数：点击每一个元素输出的都是 4 for (var i =0;i&lt;aLi.length;i++) &#123; aLi[i].onclick=function ()&#123; console.log(i); &#125; &#125;// 闭包函数：使用闭包后，点击对应的元素，输出的是对应元素的索引值 for (var i =0;i&lt;aLi.length;i++) &#123; (function (i)&#123; aLi[i].onclick=function ()&#123; console.log(i); &#125; &#125;)(i); &#125; // 方法二 for (var i =0;i&lt;aLi.length;i++) &#123; aLi[i].onclick=(function (i)&#123; return function ()&#123; console.log(i); &#125; &#125;)(i); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包的注意事项 闭包在IE8-下会引发内存泄漏：内存泄漏就是指浏览器不关闭,内存一直不会被释放 在理解内存泄漏时，我们先来了解一下JS中的垃圾回收机制： JS中的内存回收是自动回收的，主要有两种方式: ​ (1) 标记清除 ​ 变进入环境（例如，在函数中声明一个变量），则将这个变量标记为’进入环境’，当变量离开环境时，则将其标记为离开环境。垃圾收集器会自动回收那些离开环境的变量所占用的内存 (2) 引用计数 ​ 引用计数的含义是跟踪每一个值被引用的次数。当声明一个变量并将一个值赋给该变量，则这个值的引用次数加1。如果这个变量又取了另外一个值，则这个值得引用次数减1，当这个值得引用次数变为0时，就可以将其占用的内存空间回收回来。 ​ 内存泄漏就是由于引用计数方式中的循环引用造成的，在下面的例子中，oBjectA和objectB分别指向一个Object类型的对象，则这两个对象的引用计数都是1，然后oBjectA和objectB通过各自的属性互相引用，oBjectA和objectB指向的那两个对象的引用计数都变成了2，这样就造成内存无法回收。（这里希望大家搞 清楚一个概念，oBjectA和objectB的值才是对象，oBjectA和objectB本身是变量）。现代浏览器都是采用标记清除的垃圾回收策略，但是在IE8-中的BOM和DOM并不是原生的JavaScript对象，其BOM和DOM使用c++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略 1234567 function fn()&#123; var objectA = new Object(); var objectB = new Object(); objectA.attr1 = objectB; objectB.attr = objectA;&#125; ES6中新特性在ES5和之前的版本中，没有块级作用域的概念，所以开发人员巧妙的利用闭包来实现块级作用域，以满足开发需求。但是在ES6中新增了let和const命令，并且定义了块级作用域的命令，所以闭包以后将会慢慢废弃，我们只需要了解有这个东西即可，重要的是积极学习使用ES6的新特性，这里推荐下阮一峰老师的ECMAScript 6 入门。 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用let命令代替var我们可以改写一下上面的for循环 123456// 改成let命令后，点击每个元素时，输出的是对应元素的索引，不需要再使用闭包了for (let i =0;i&lt;aLi.length;i++) &#123; aLi[i].onclick=function ()&#123; console.log(i); &#125; &#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gyunzhi.github.io/tags/JavaScript/"}]},{"title":"前端安全配置Content-Security-Policy","date":"2018-06-15T19:09:59.000Z","path":"2018/06/16/前端安全配置Content-Security-Policy/","text":"什么是CSP​ CSP全称Content Security Policy (内容安全策略),是为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规则可以指定可信的内容来源（这里的内容可以指脚本、图片、iframe、font、style等等可能的远程的资源）。 CSP的作用​ 跨域脚本攻击 XSS（Cross Site Scripting ） 是最常见、危害最大的网页安全漏洞，为了防止它们，要采取很多编程措施，非常麻烦。通过制定CSP 策略，开发者可以明确告诉浏览器，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，即让浏览器自动禁止外部注入恶意脚本。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。 常用指令说明​ 指令是CSP 中用来定义策略的基本单位，CSP 提供了很多指令，涉及安全的各个方面，我们可以使用单个或者多个指令组合在一起来防护我们的网站。 获取指令（以下指令可以限制各类资源的加载） script-src：外部脚本 style-src：样式表 img-src：图像 media-src：媒体文件（音频和视频） font-src：字体文件 object-src：插件（比如 Flash） child-src：框架 frame-ancestors：嵌入的外部资源（比如） connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等） worker-src：worker脚本 manifest-src：manifest 文件 注意：default src 用来设置上面各个选项的默认值： 1Content-Security-Policy: default-src 'self' 上面代码限制所有的外部资源，都只能从当前域名加载。 如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值 。 报告指令 ​ 有时，我们不仅希望防止 XSS，还希望记录此类行为。report-uri就用来告诉浏览器，应该把注入行为报告给哪个网址。 1Content-Security-Policy: default-src 'self'; ...; report-uri /csp_report_url; 上面代码指定，将注入行为报告给/csp_report_url这个 URL。 浏览器会使用POST方法，发送一个JSON对象，下面是一个例子： 123456789&#123; \"csp-report\": &#123; \"document-uri\": \"http://example.org/page.html\", \"referrer\": \"http://evil.example.com/\", \"blocked-uri\": \"http://evil.example.com/evil.js\", \"violated-directive\": \"script-src 'self' https://apis.google.com\", \"original-policy\": \"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser\" &#125;&#125; 指令值 主机名：example.org，https://example.com:443 路径名：example.org/resources/js/ 通配符：*.example.org，*://*.example.com:*（表示任意协议、任意子域名、任意端口） 协议名：https:、data: ：只允许通过https、data协议加载资源 关键字&#39;self&#39;：当前域名，需要加引号 关键字&#39;none&#39;：禁止加载任何外部资源，需要加引号 除了常规值，script-src还可以设置一些特殊值，注意，下面这些值都必须放在单引号里面。 1234unsafe-inline：允许执行页面内嵌的`&amp;lt;script&gt;`标签和事件监听函数unsafe-eval：允许将字符串当作代码执行，比如使用`eval`、`setTimeout`、`setInterval`和`Function`等函数nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行 如何启用CSP两种方法可以启用 CSP，一种是通过网页的&lt;meta&gt;标签，另一种是通过 HTTP 头信息的Content-Security-Policy的字段。 1、通过meta标签启用CSP： 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:\"&gt; 上面代码中，CSP 做了如下配置： 脚本：只信任当前域名 &lt;object&gt;标签：不信任任何URL，即不加载任何资源 样式表：只信任cdn.example.org和third-party.org 框架（frame）：必须使用HTTPS协议加载 其他资源：没有限制 2、服务器端配置Content-Security-Policy启用 Apache 在VirtualHost的httpd.conf文件中添加如下代码 1Header set Content-Security-Policy \"default-src 'self';\" Nginx 在 server 对象块中添加如下代码 1add_header Content-Security-Policy \"default-src 'self';\" 相关阅读链接 Content Security Policy 入门教程 [前端安全配置之Content-Security-Policy","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://gyunzhi.github.io/tags/Web安全/"}]},{"title":"App Links和Universal Links的配置和使用","date":"2018-04-16T22:39:31.000Z","path":"2018/04/17/App Links和Universal Links的配置和使用/","text":"之前的有一篇博文介绍了Scheme的方式来实现App之间的跳转，但是这种方式有一个问题，就是当我们的移动设备上没有安装该App时，它不能做其他的处理，比如跳转到我们公司的网站里面。在2015年，Google和Apple分别提出了和App Links（只支持Android M及以上系统）和Universal Links（只支持IOS9及以上系统）这两个新特性。这两种方式，可以通过访问HTTP/HTTPS链接直接唤起APP进入具体页面，不需要其他额外判断；如果未安装App，访问此链接时，可以展示你网站的内容。这两种方式有一个要求，你需要有一个域名和自己的服务器，下面分别介绍这两种方式： App Links1. 在AndroidManifest.xml激活App links1234567&lt;intent-filter android:autoVerify=\"true\"&gt; &lt;!--App Links启动--&gt; &lt;action android:name=\"android.intent.action.VIEW\"&gt;&lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"&gt;&lt;/category&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"http\" android:host=\"www.yourdomain.com.com\" /&gt; &lt;data android:scheme=\"https\" android:host=\"www.yourdomain.com.com\" /&gt;&lt;/intent-filter&gt; 这个配置告诉安卓去验证一个文件，这个文件地址是https://yourdomain.com/.well-known/statements.json,如果存在这个文件，同时验证成功，那么用户点击该域名之下的链接时，就可以直接到app，下一步，我们将学会如何构建这个文件。 2. 上传web-app关联文件（statements.json）基于安全的原因，这个文件必须通过SSL的GET请求获得，所以你需要下载一个SSL证书，并且配置在你的服务器中，然后你可以打开一个文本编辑器，写入如下形式的JSON： 12345678[&#123; \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": &#123; \"namespace\": \"android_app\", \"package_name\": \"com.mycompany.myapp\", \"sha256_cert_fingerprints\": [\"6C:EC:C5:0E:34:AE....EB:0C:9B\"] &#125;&#125;] 你可以在AndroidManifest.xml 文件中找到app的package name。你还需要通过在终端中执行以下命令查看keystore参数信息来找到sha256指纹(关于生成签名密钥，你可以看下我之前的文章)： 1keytool -list -v -keystore my-release-key.keystore 注： 你可以通过Statement List Generator and Tester这个网站来自动生成和测试statements.json文件， 目前可以通过http获得这个文件，但是在M最终版里则只能通过HTTPS验证。确保你的web站点支持HTTPS请求。 3.上传这个文件到服务器的.well-known文件夹如果你的服务器是windows系统，.well-know文件夹可以通过命令行的形式创建。 Universal Links1. 注册App并打开Associated Domains服务如果你还没有注册App，则需要登陆developer.apple.com注册。然后在Identifiers下AppIDs找到自己的App ID，并打开Associated Domains服务。 2. 在Xcode中开启Associated Domains服务 打开Associated Domains服务 添加域名，点击Associated Domains的“+”添加前缀为applinks:的域名，如下图所示 3.配置apple-app-site-association文件文件格式如下图所示： paths对应域名中的path，用于过滤可以跳转到App的链接，支持通配符‘*’，‘？’以及‘NOT’进行匹配，匹配的优先级是从左至右依次降低。 appID对应项由前缀和ID两部分组成，可以在developer.apple.com中的Identifiers→AppIDs中点击对应的App ID查看。 4.上传这个文件到服务器的.well-known文件夹IOS下仅支持不支持HTTPS获取apple-app-site-association文件，所以我们必须要在服务器中配置SSL证书 相关阅读链接 Android M App Links实现 IOS9 Universal Links的使用","tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://gyunzhi.github.io/tags/React-Native/"}]},{"title":"浅析移动端深度链接技术","date":"2018-03-29T16:57:23.000Z","path":"2018/03/30/浅析移动端深度链接技术/","text":"​ 公司的后台管理App，是使用React Native框架来写的，RN框架屏蔽了IOS和Android之间开发方式的差异，使得前端可以通过JavaScript来开发跨平台的原生App，前段时间收到一个需求，需要在App中打开第三方的App并进入某个特定的界面。于是去看了一下RN的官方文档和网上的一些关于App之间通信的技术文章。了解到了深度链接这个东西，但是很多文章要么讲解的不是很清楚，要么就是很久之前的东西，而且没有针对于RN框架来展开的具体的介绍，所以打算自己写一篇博客给大家分享一下深度链接技术。 什么是深度链接​ 所谓深度链接，简单来讲，就是你在手机上点击一个链接之后，可以打开某个App或者是直接进入到这个App内部的某个页面，而不是App正常打开时显示的首页。 如何实现深度链接​ 就目前来讲，实现深度链接主要有以下三种方式，这篇文章我们主要介绍URL Scheme的方式来实现深度链接： URL Scheme iOS，Android平台都支持 Universal Links 只支持iOS9及以上系统 App Links 只支持Android6.0及以上系统 1.什么是URL Scheme 通过对比网页链接来理解 URL Scheme，应就容易多了。 URL Scheme 有两个单词： URL，我们都很清楚，http://www.apple.com 就是个 URL，我们也叫它链接或网址； Scheme，表示的是一个 URL 中的一个位置—最初始的位置，即 ://之前的那段字符。比如 http://www.apple.com 这个网址的 Scheme 是 http（可以理解为URL地址的协议）。 根据我们上面对 URL Schemes 的了解，我们可以很轻易地理解，在手机中，我们可以像定位一个网页一样，用一种特殊的 URL 来定位一个应用甚至应用里某个具体的功能。而定位这个应用的，就是这个应用的URL 的 Scheme 部分，也就是开头儿那部分。比如短信，就是 sms: 下面用苹果的网站和 iOS 上的微信来做个简单对比： 网页（苹果）iOSiOS网站首页/打开应用http://www.apple.comweixin://子页面/具体功能http://www.apple.com/mac/（Mac页面）weixin://dl/moments（朋友圈） 在这里，http://www.apple.com 和 weixin:// 都声明了这是谁的地盘。然后在 http://www.apple.com 后面加上 /mac 就跳转到从属于 http://www.apple.com 的一个网页上；同样，在 weixin:// 后面加上 dl/moments 就进入了微信的一个具体的功能——朋友圈。 但是，两者还有几个重要的区别： 所有网页都一定有网址，不管是首页还是子页。但未必所有的应用都有自己的 URL Scheme，更不是每个应用的每个功能都有相应的 URL Scheme。实际上，现状是，大多数的应用只有用于打开应用的 URL Scheme，而有一些应用甚至没有用于打开应用的 URL Scheme。几乎没有所有功能都有对应 URL 的应用。一个 App 是否支持 URL Schemes 要看那个 App 的作者是否在自己的作品里添加了支持 URL Schemes 相关的代码。 一个网址只对应一个网页，但并非每个 URL Scheme 都只对应一款应用。因为URL Schemes是可以重复的，所以曾经出现过有 App 使用支付宝的 URL Schemes 拦截支付帐号和密码的事件。 2.如何通过URL Scheme实现深度链接通过下面这张图来说明APP1与APP2之间，在技术上，如何完成横向调用： 假如要从APP-F调用APP-T 1）APP-T要进行自定义scheme的配置（iOS是info文件，Android是activity），并且可以对传入的参数进行处理。 2）APP-F进行调用，首先判断设备是否安装APP-T。 3）如果未安装，则跳转到APP-T的web版应用（假设他提供web版）或者是跳转到AppStore等应用市场进行下载。 4）如果已安装，则调用APP-T配置好的URL SCHEME，直接打开APP-T的相关界面。 自定义URL Scheme配置​ 要想你的应用支持URL Scheme，你需要在应用里面进行配置，IOS和Android配置的方法是不一样的，下面会详细讲一下两者配置的步骤： IOS第一步是创建 URL Scheme — 在 Xcode Project Navigator 中找到并点击工程 info.plist 文件。当该文件显示在右边窗口，在列表上点击鼠标右键，选择 Add Row: 向下滚动弹出的列表并选择 URL types 点击左边剪头打开列表，可以看到 Item 0，一个字典实体。展开 Item 0，可以看到 URL Identifier，一个字符串对象。该字符串是你自定义的 URL scheme 的名字。建议采用反转域名的方法保证该名字的唯一性，比如 com.yourCompany.yourApp。 点击 Item 0 新增一行，从下拉列表中选择 URL Schemes，敲击键盘回车键完成插入。 注意 URL Schemes 是一个数组，允许应用定义多个 URL schemes。 展开该数据并点击 Item 0。你将在这里定义自定义 URL scheme 的名字。只需要名字，不要在后面追加 :// — 比如，如果你输入 iOSDevApp，你的自定义 url 就是 iOSDevApp:// 此时，整个定义如下图: 虽然我赞同 Xcode 使用描述性的名字的目的，不过看到创建的实际的 key 也是非常有用的。这里有一个方便的技巧，右键点击 plist 并选择 Show Raw Keys/Values，就能看到以下效果: 还有另一种有用的输出格式，XML，因为可以非常容易的看到字典和原始数组及其包括的实体的结构。点击 plist 并选择 Open As – Source Code: AndroidAndroid应用/组件间通信有一种方式是intent，应用可以注册intent filter声明自己对什么样的intent感兴趣，其它应用发送intent时通过系统级广播传递过来，如果与预先注册的intent filter匹配，应用将收到该intent（无论应用是否正在运行，都会被“唤醒”，也就是隐式启动Activity），并取出intent携带的数据，做进一步处理，所以我们需要在AndroidManifest.xml里静态注册intent filter来声明自定义的URL Scheme： 1234567891011121314151617 &lt;activity android:name=\".MainActivity\" android:launchMode=\"singleTask\" android:label=\"@string/app_name\" android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\" android:windowSoftInputMode=\"adjustResize\"&gt; &lt;intent-filter&gt; &lt;!-- 正常启动 --&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;!-- URL Scheme启动 --&gt; &lt;action android:name=\"android.intent.action.VIEW\"&gt;&lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"&gt;&lt;/category&gt; &lt;data android:scheme=\"myapp\"&gt;&lt;/data&gt; &lt;/intent-filter&gt;&lt;/activity&gt; React Native提供的Liking API处理深度链接在RN的官方文档中提供了Liking这个API让我们处理深度链接来实现App之间的跳转。 处理传入的链接如果你的应用被其注册过的外部url调起，则可以在任何组件内这样获取和处理它： 1234567componentDidMount() &#123; Linking.getInitialURL().then((url) =&gt; &#123; if (url) &#123; console.log('Initial url is: ' + url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err));&#125; 注意：getInitialURL方法只有在App第一次启动的时候会执行，如果App已经启动但是进程挂到后台，通过深度链接打开该App的时候不会执行getInitialURL方法，所以需要用到addEventListener方法，确保每次打开App时都能知道我们的App是被哪个链接调起的。 如果要在MainActivity实例存在（即App进程没有关闭的时候）的时候监听传入的intent，那么需要在AndroidManifest.xml中将MainActivity的launchMode设置为singleTask。 123&lt;activity android:name=\".MainActivity\" android:launchMode=\"singleTask\"&gt; 对于iOS来说，如果要在App启动后也监听传入的App链接，需要在AppDelegate.m中增加以下代码： 123456789// iOS 9.x or newer#import &lt;React/RCTLinkingManager.h&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options&#123; return [RCTLinkingManager application:application openURL:url options:options];&#125; 123456789// iOS 8.x or older#import &lt;React/RCTLinkingManager.h&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation];&#125; 然后你的React组件就可以监听Linking的相关事件： 123456789componentDidMount() &#123; Linking.addEventListener('url', this._handleOpenURL);&#125;,componentWillUnmount() &#123; Linking.removeEventListener('url', this._handleOpenURL);&#125;,_handleOpenURL(event) &#123; console.log(event.url);&#125; 打开外部链接要启动一个链接相对应的应用（打开浏览器、邮箱或者其它的应用），只需调用： 1Linking.openURL(url).catch(err =&gt; console.error('An error occurred', err)); 如果想在打开链接前先检查是否安装了对应的应用，则调用以下方法： 1234567Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125;&#125;).catch(err =&gt; console.error('An error occurred', err)); 注意：在IOS平台，打开外部链接需要配置Scheme白名单 在项目的info.plist中添加一LSApplicationQueriesSchemes，类型为Array； 添加需要支持的项目，类型为字符串类型； 相关阅读链接 移动端Deeplink的前世今生 自定义URL Scheme完全指南 如何自定义 URL Scheme 进行跳转 唤醒App的那些事 H5页面唤醒App","tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://gyunzhi.github.io/tags/React-Native/"}]},{"title":"Android环境生成签名密钥、打包APK","date":"2018-02-25T17:08:23.000Z","path":"2018/02/26/Android环境生成签名密钥、打包APK/","text":"Android要求所有应用都有一个数字签名才会被允许安装在用户手机上，所以在把应用发布到类似Google Play store这样的应用市场之前，你需要先生成一个签名的APK包。Android开发者官网上的如何给你的应用签名文档描述了签名的细节。本指南旨在提供一个简化的签名和打包APK的操作步骤，不会涉及太多理论。 生成一个签名密钥你可以用keytool命令生成一个私有密钥。在Windows上keytool命令放在JDK的bin目录中（比如C:\\Program Files\\Java\\jdkx.x.x_x\\bin），如果你没有配置Java环境变量的话，需要先进入那个目录才能在命令行中执行此命令。 1$ keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 执行命令后会要求你输入密钥库（keystore）和对应密钥的密码，然后设置一些发行相关的信息。最后它会在当前目录下生成一个叫做my-release-key.keystore的密钥库文件。在运行上面这条语句之后，密钥库里应该已经生成了一个单独的密钥，有效期为10000天。–alias参数后面的别名是你将来为应用签名时所需要用到的，所以记得记录这个别名。 1查看keystore参数信息：keytool -list -v -keystore my-release-key.keystore 注意：请记得妥善地保管好你的密钥库文件，不要上传到版本库或者其它的地方。 设置gradle变量 把my-release-key.keystore文件放到你工程中的android/app文件夹下。 编辑用户目下的~/.gradle/gradle.properties或者是RN项目中下的android/gradle.properties文件，添加如下的代码（注意把其中的****替换为相应密码） 注意：~表示用户目录，比如windows上可能是C:\\Users\\用户名，而mac上可能是/Users/用户名。 1234MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 上面的这些会作为全局的gradle变量，我们在后面的步骤中可以用来给应用签名。 关于密钥库的注意事项: 一旦你在Play Store发布了你的应用，如果想修改签名密钥，就必须用一个不同的包名来重新发布你的应用（这样也会丢失所有的下载数和评分）。所以请务必备份好你的密钥库和密码。 提示：如果你不想以明文方式保存密码，同时你使用的是macOS系统，那么你也可以把密码保存到钥匙串（Keychain）中。这样一来你就可以省略掉上面配置中的后两行（即MYAPP_RELEASE_STORE_PASSWORD和MYAPP_RELEASE_KEY_PASSWORD）。 添加签名到项目的gradle配置文件编辑你项目目录下的android/app/build.gradle，添加如下的签名配置： 1234567891011121314151617181920...android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125;&#125;... 生成发行APK包只需在终端中运行以下命令： 1$ cd android &amp;&amp; ./gradlew assembleRelease 译注：cd android表示进入android目录（如果你已经在android目录中了那就不用输入了）。./gradlew assembleRelease在macOS、Linux或是windows的PowerShell环境中表示执行当前目录下的名为gradlew的脚本文件，且其运行参数为assembleRelease，注意这个./不可省略；而在windows的传统CMD命令行下则需要去掉./。 Gradle的assembleRelease参数会把所有用到的JavaScript代码都打包到一起，然后内置到APK包中。如果你想调整下这个行为（比如js代码以及静态资源打包的默认文件名或是目录结构等），可以看看android/app/build.gradle文件，然后琢磨下应该怎么修改以满足你的需求。 生成的APK文件位于android/app/build/outputs/apk/app-release.apk，它已经可以用来发布了。 测试应用的发行版本在把发行版本提交到Play Store之前，你应该做一次最终测试。输入以下命令可以在设备上安装发行版本： 1$ cd android &amp;&amp; ./gradlew installRelease 注意installRelease参数只能在你完成了上面的签名配置之后才可以使用。你现在可以关掉运行中的packager了，因为你所有的代码和框架依赖已经都被打包到apk包中，可以离线运行了。 在debug和release版本间来回切换安装时可能会报错签名不匹配，此时需要先卸载前一个版本再尝试安装。 针对设备不同的CPU架构生成APK以减小APK文件的大小默认情况下，生成的APK会同时包含针对于x86和ARMv7aCPU架构的原生代码。 这样可以让我们更方便的向其他人分享这个APK，因为它几乎可以运行在所有的Android设备上。 但是，这有一个缺点，首先是APK文件更大，其次任何设备上都会有一些未使用的代码。 你可以在android/app/build.gradle:修改如下代码来打包生成针对不同CPU架构的APK 12- def enableSeparateBuildPerCPUArchitecture = false+ def enableSeparateBuildPerCPUArchitecture = true 你可以把这上面打包生成的两个APK都上传到支持对用户设备CPU架构定位的应用程序商店，例如Google Play和Amazon AppStore，用户将自动获得相应的APK。如果您想上传到其他市场，例如APKFiles（不支持一个应用有多个APK文件），可以修改下面的代码，来生成适用不同CPU架构的通用APK。 12- universalApk false + universalApk true // 设置为true的时候会再生成一个通用APK 启用Proguard来减小APK文件的大小（可选）Proguard是一个减小APK的大小的工具，它通过移除掉React Native Java字节码文件（和它的依赖库中）中没有被使用到的部分，最终有效的减少APK的大小。 重要：启用Proguard之后，你必须再次全面地测试你的应用。Proguard有时候需要为你引入的每个原生库做一些额外的配置。参见app/proguard-rules.pro文件。 在android/app/build.gradle文件中修改如下代码来启用Proguard 12- def enableProguardInReleaseBuilds = false + def enableProguardInReleaseBuilds = true 启动Proguard后需清空缓存，否则可能会报错： 1cd android &amp;&amp; ./gradlew.bat clean","tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://gyunzhi.github.io/tags/React-Native/"}]},{"title":"CenterOS7部署静态博客","date":"2018-02-19T20:09:59.000Z","path":"2018/02/20/CenterOS7部署静态博客/","text":"12yum install nginx 安装nginx yum install git 安装git （git clone ...） 静态文放在/usr/src/blog下 12345678910systemctl enable nginx 系统启动时运行nginx# centos6.xservice nginx start 启动nginx服务service nginx stop 停止nginx服务service nginx reload 重启nginx服务# centos7.xsystemctl start nginx 启动nginx服务systemctl stop nginx 停止nginx服务systemctl reload nginx 重启nginx服务 1234pwd 查看当前目录ll/dir 查看目录下文件和文件夹mv 文件名 新文件名 修改文件名称vi nginx.conf 编辑文件 1234567891011121314151617181920212223242526272829303132user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include /etc/nginx/conf.d/*.conf; #关闭默认的配置 #自定义监听端口，指定静态站点所在目录 server &#123; listen 80; server_name localhost; root /usr/src/blog; index index.html index.htm; &#125;&#125; 开启https时nginx配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; \\#tcp_nopush on; keepalive_timeout 65; \\#gzip on; \\#include /etc/nginx/conf.d/*.conf; server &#123; listen 443; server_name www.xxx.cn; #填写绑定证书的域名 ssl on; ssl_certificate ./conf.d/1_www.xxx.cn_bundle.crt; ssl_certificate_key ./conf.d/2_www.xxx.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root /usr/src/blog; #站点目录 index index.html index.htm; &#125; &#125; server &#123; listen 80; server_name localhost; location / &#123; root /usr/src/blog; #站点目录 index index.html index.htm; rewrite ^(.*) https://$host$1 permanent; // 80端口请求重定向到https &#125; &#125;&#125;","tags":[{"name":"服务器","slug":"服务器","permalink":"https://gyunzhi.github.io/tags/服务器/"}]},{"title":"使用gulp对博文进行压缩","date":"2018-02-14T22:06:23.000Z","path":"2018/02/15/使用gulp对博文压缩/","text":"默认情况下，使用hexo generate命令生成的静态文件没有经过压缩，代码之间会有很多空白行和注释，可以通过gulp对 public 目录中的静态资源文件进行压缩，减少网站整体尺寸大小。下面是具体的步骤： 安装npm安装完后替换为淘宝镜像源避免因网速问题导致文件下载不全： 12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 安装gulp安装gulp需要全局安装一次，再本地环境安装一次，参见gulp入门指南 12npm install gulp -gnpm install gulp --save-dev 安装gulp相关插件需要用到以下插件 delgulp-clean-cssgulp-htmlcleangulp-htmlmingulp-imagemingulp-uglifyrun-sequence 1234567npm install del --save-devnpm install gulp-clean-css --save-devnpm install gulp-htmlclean --save-devnpm install gulp-htmlmin --save-devnpm install gulp-imagemin --save-devnpm install gulp-uglify --save-devnpm install run-sequence --save-dev 编写gulpfile.js文件在hexo项目根目录下（node_modules同目录），新增gulpfile.js文件，内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');var del = require('del');var runSequence = require('run-sequence');var Hexo = require('hexo');// 清除public文件夹gulp.task('clean', function() &#123; return del(['public/**/*']);&#125;);// 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样var hexo = new Hexo(process.cwd(), &#123;&#125;);gulp.task('generate', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('generate', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; console.log(err); hexo.exit(err); return cb(err); &#125;)&#125;)// 压缩public目录下的所有cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8', rebase: false, &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩public目录下的所有htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩public目录下的所有jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩public目录下的所有img： 这个采用默认配置gulp.task('minify-img', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin()) .pipe(gulp.dest('./public/images'))&#125;)// 同上，压缩图片，这里采用了： 最大化压缩效果。gulp.task('minify-img-aggressive', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/images'))&#125;)// 用run-sequence并发执行，同时处理html，css，js，imggulp.task('compress', function(cb) &#123; runSequence(['minify-html', 'minify-css', 'minify-js', 'minify-img-aggressive'], cb);&#125;);// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆gulp.task('build', function(cb) &#123; runSequence('clean', 'generate', 'compress', cb)&#125;);gulp.task('default', ['build']) 执行gulp压缩再部署12gulp buildhexo d","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gyunzhi.github.io/tags/Hexo/"}]},{"title":"Apache虚拟主机配置","date":"2018-02-08T22:26:32.000Z","path":"2018/02/09/Apache虚拟主机配置/","text":"在一个Apache服务器上可以配置多个虚拟主机，实现一个服务器提供多站点服务，其实就是访问同一个服务器上的不同目录。Apache虚拟主机配置有3中方法：基于IP配置、基于域名配置和基于端口配置，这里只介绍基于域名配置和基于端口配置，基于IP配置方法类似。 基于域名配置虚拟主机找到配置文件/conf/extra/httpd-vhosts.conf 首先配置localhost，以免之后访问localhost出现问题 12345678910&lt;VirtualHost *:80&gt; DocumentRoot \"D:/wamp/www\" ServerName localhost &lt;Directory \"D:/wamp/www\"&gt; Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 配置其他项,可配置多项 12345678910&lt;VirtualHost *:80&gt; DocumentRoot \"C:/wamp/www/test\" ServerName www.test.com &lt;Directory \"C:/wamp/www/test\"&gt; Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 这里配置了两个虚拟主机，这两个主机使用的都是80端口，第一个虚拟主机指定域名为“localhost”，服务器目录为“D:/wamp/www”，第二个虚拟主机指定域名为”www.test.com ”，服务器目录为“D:/wamp/www/test”。 然后在Apache主配置文件conf/httpd.conf中包含这个配置文件，去掉前面的#就可以了： 12- #Include conf/extra/httpd-vhosts.conf + Include conf/extra/httpd-vhosts.conf 最后重启Apache服务器，就可以通过访问两个不同的域名访问同一个服务器上的两个目录了。 注意：如果只是在本地进行配置测试的话，需要在hosts文件中加入域名到本地IP地址的映射（hosts文件位置：C:\\Windows\\System32\\drivers\\etc）： 12 127.0.0.1 localhost 127.0.0.1 www.test.com 基于端口配置虚拟主机 首先在Apache配置文件conf/httpd.conf中修改配置让Apache服务器监听多个端口： 12 Listen 8080 Listen 80 这里监听两个端口，配置两个虚拟主机。 然后在配置文件conf/extra/httpd-vhosts.conf，添加如下配置信息： 123&lt;VirtualHost _default_:80&gt; DocumentRoot \"D:/wamp/www\"&lt;/VirtualHost&gt; 12345678&lt;VirtualHost *:8080&gt; DocumentRoot \"D:/wamp/www/test\" &lt;Directory \"D:/wamp/www/test\"&gt; Options Indexes FollowSymLinks MultiViews AllowOverride None Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 在Apache主配置文件conf/httpd.conf中包含这个配置文件： 12- #Include conf/extra/httpd-vhosts.conf+ Include conf/extra/httpd-vhosts.conf 最后重启Apache服务器，就可以通过同一个IP地址的不同端口来访问同一个服务器上的两个不同目录了。 注意：Web服务器默认使用的是80端口，所以访问80端口的站点时可以不用加上“：80”，但是访问其他端口时必须带上端口号。 host文件的说明在Window系统中有个hosts文件（没有后缀名），在Window7下(C:\\Windows\\System32\\drivers\\etc)，该文件其实是一个纯文本的文件，用普通的文本编辑软件如记事本等都能打开。 这个文件是根据TCP/IPforWindows的标准来工作的，它的作用是包含IP地址和Host name(主机名)的映射关系，是一个映射IP地址和Hostname(主机名)的规定，规定要求每段只能包括一个映射关系，IP地址要放在每段的最前面，空格后再写上映射的Host name(主机名)。对于这段的映射说明用“#”分割后用文字说明。 现在让我们来看看hosts在Windows中是怎么工作的。我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成XXX.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而hosts文件就能提高解析效率。根据Windows系统规定，在进行DNS请求以前，Windows系统会先检查自己的hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向已知的DNS服务器提出域名解析。也就是说hosts的请求级别比DNS高。知道了hosts文件的工作方式，那在具体使用中它有哪些作用呢? 1、加快域名解析​ 对于要经常访问的网站，我们可以通过在hosts中配置域名和IP的映射关系，这样当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。 2、方便局域网用户​ 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。 3、屏蔽网站​ 现在有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或自己计算机的IP，这样就不用访问了。我们在hosts写上以下内容：127.0.0.1 #屏蔽的网站0.0.0.0 #屏蔽的网站这样计算机解析域名就解析到本机或错误的IP，达到了屏蔽的目的。 4、顺利连接系统​ 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好hosts文件，这样输入服务器名就能顺利连接了。​ 最后要指出的是，hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 相关阅读链接 Apache虚拟主机的配置 Host文件的作用和介绍","tags":[{"name":"服务器","slug":"服务器","permalink":"https://gyunzhi.github.io/tags/服务器/"}]},{"title":"Linux 基础入门","date":"2018-02-07T16:08:23.000Z","path":"2018/02/08/Linux 基础入门/","text":"Linux 基础入门目录操作创建目录使用 mkdir 命令创建目录 1mkdir $HOME/testFolder 切换目录使用 cd 命令切换目录 1cd $HOME/testFolder 使用 cd ../ 命令切换到上一级目录 1cd ../ 移动目录使用 mv 命令移动目录 1mv $HOME/testFolder /var/tmp 删除目录使用 rm -rf 命令删除目录 1rm -rf /var/tmp/testFolder 查看目录下的文件使用 ls 命令查看 [/etc] 目录下所有文件和文件夹 1ls /etc /etc 目录默认是 *nix 系统的软件配置文件存放位置 文件操作 任务时间：5min ~ 10min 创建文件使用 touch 命令创建文件 1touch ~/testFile 执行 ls 命令, 可以看到刚才新建的 testFile 文件 1ls ~ 复制文件使用 cp 命令复制文件 1cp ~/testFile ~/testNewFile 删除文件使用 rm 命令删除文件, 输入 y 后回车确认删除 1rm ~/testFile 查看文件内容使用 cat 命令查看 .bash_history 文件内容 1cat ~/.bash_history 过滤, 管道与重定向 任务时间：5min ~ 10min 过滤过滤出 /etc/passwd 文件中包含 root 的记录 1grep 'root' /etc/passwd 递归地过滤出 /var/log/ 目录中包含 linux 的记录 1grep -r 'linux' /var/log/ 管道简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 | 比如, 我们可以将 cat 和 grep 两个命令用管道组合在一起 1cat /etc/passwd | grep 'root' 过滤出 /etc 目录中名字包含 ssh 的目录(不包括子目录) 1ls /etc | grep 'ssh' 重定向可以使用 &gt; 或 &lt; 将命令的输出重定向到一个文件中 1echo 'Hello World' &gt; ~/test.txt 运维常用命令 任务时间：5min ~ 10min ping 命令对 cloud.tencent.com 发送 4 个 ping 包, 检查与其是否联通 1ping -c 4 cloud.tencent.com netstat 命令netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等 列出所有处于监听状态的tcp端口 1netstat -lt 查看所有的端口信息, 包括 PID 和进程名称 1netstat -tulpn ps 命令过滤得到当前系统中的 ssh 进程信息 1ps -aux | grep 'ssh'","tags":[{"name":"Linux","slug":"Linux","permalink":"https://gyunzhi.github.io/tags/Linux/"}]},{"title":"Apache、Nginx、Tomcat作用和使用场景","date":"2018-02-05T23:26:32.000Z","path":"2018/02/06/Apache、Nginx、Tomcat作用和使用场景/","text":"Apache—HTTP服务器（Web服务器）HTTP服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等资源。下图描述的就是这一过程： 不仅仅是Apache HTTP Server和Nginx，绝大多数编程语言所包含的类库中也都实现了简单的HTTP服务器方便开发者使用： HttpServer (Java HTTP Server ) Python SimpleHTTPServer 使用这些类库能够非常容易的运行一个HTTP服务器，它们都能够通过绑定IP地址并监听tcp端口来提供HTTP服务。 NginxNginx is a free,open-source,high-performance http server and reverse proxy,as well as an IMAP/POP3 proxy. 通俗的说Nginx提供web服务，反向代理，以及IMAP/POP3代理，那么什么是web服务？反向代理？IMAP/POP3代理？ web服务：服务端通过网络可以提供给客户端所请求的资源 反向代理：代表资源服务器来回应客户端的请求，至于资源服务器为什么不自己回应后面会解释 IMAP/POP3：是一种stream传输协议，常常被用来做一些邮件传输 IMAP：Internet Mail Access Protocol 是一种交互式的邮件传输协议，交互式说的就是客户端可以和服务端针对邮件的各种操作同步，一份邮件，客户端有，服务端也有，客户端有什么操作会同步到服务端，反之亦然。 POP3：Post Office Protocol 3邮件传输协议相比IMAP协议只是服务器不保留邮件，一旦给了客户端，自行删除对应的邮件，客户端对邮件的各种操作与服务器无关 注意代理的概念只要把握准正向和反向都是以客户端为参考的，从客户端发出的是正向，客户端接受的是反向，类似于原告的代理律师—正向代理；被告的代理律师—反向代理 TomcatApache Tomcat则是Apache基金会下的另外一个项目，与Apache HTTP Server相比，Tomcat能够动态的生成资源并返回到客户端。Apache HTTP Server和Nginx都能够将某一个文本文件的内容通过HTTP协议返回到客户端，但是这个文本文件的内容是固定的——也就是说无论何时、任何人访问它得到的内容都是完全相同的，这样的资源我们称之为静态资源。动态资源则与之相反，在不同的时间、不同的客户端访问得到的内容是不同的，例如： 包含显示当前时间的页面 显示当前IP地址的页面 Apache HTTP Server和Nginx本身不支持生成动态页面，但它们可以通过其他模块来支持（例如通过Shell、PHP、Python脚本程序来动态生成内容）。如果想要使用Java程序来动态生成资源内容，使用这一类HTTP服务器很难做到。Java Servlet技术以及衍生的Java Server Pages技术可以让Java程序也具有处理HTTP请求并且返回内容（由程序动态控制）的能力，Tomcat正是支持运行Servlet/JSP应用程序的容器（Container）: Tomcat运行在JVM之上，它和HTTP服务器一样，绑定IP地址并监听TCP端口，同时还包含以下职责： 管理Servlet程序的生命周期 将URL映射到指定的Servlet进行处理 与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器 动静态资源分离——运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。 负载均衡，当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理","tags":[{"name":"服务器","slug":"服务器","permalink":"https://gyunzhi.github.io/tags/服务器/"}]}]