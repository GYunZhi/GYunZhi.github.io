<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学会学习的人，是幸福的人"><title>Javascript异步编程的演进 | Hi, MrGong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javascript异步编程的演进</h1><a id="logo" href="/.">Hi, MrGong</a><p class="description"></p></div><div id="nav-menu"> <a href="/." class="current"><i class="fa fa-home">首页</i></a> <a href="/archives/"><i class="fa fa-archive">归档</i></a> <a href="/about/"><i class="fa fa-user">关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Javascript异步编程的演进</h1><div class="post-meta"><a href="/2018/09/09/Javascript异步编程的演进/#comments" class="comment-count"></a><p><span class="date">Sep 09, 2018</span><span><a href="/categories/JavaScript/" class="category">JavaScript</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、Javascript-异步的由来"><a href="#一、Javascript-异步的由来" class="headerlink" title="一、Javascript 异步的由来"></a>一、Javascript 异步的由来</h2><h3 id="Javascript-单线程"><a href="#Javascript-单线程" class="headerlink" title="Javascript 单线程"></a>Javascript 单线程</h3><p>大家都知道 js 是单线程的，那为什么要是单线程的呢？</p><p>因为 js 的运用场景是浏览器，包含了很多用户的交互，如果是多线程，那一个线程要在某个 DOM 上添加内容，另一个线程直接要删除这个 DOM，那浏览器到底听哪个的好呢？所以为了降低复杂性，js 从一诞生，就是单线程，这也是这门语言的核心特征，因为 js 一开始就是为浏览器而生的。</p><p>既然是单线程，也就是每次只执行一个任务，只有等到当前任务执行完毕，才能执行后面的任务，这些任务会形成一个任务队列，排队等候执行。</p><p>就像大家去超市买东西排队结账，得前面一个人付完钱，排在他后面的那个才能买单。但是如果前面一个任务很耗时，比如正常每个人手里都是拿着一两样东西等着排队，而你前面那位大哥推着满满一车的东西，你是不是得崩溃了？</p><p>所以像我们平时遇到的浏览器无响应和页面假死，往往是因为某段 js 代码执行时间过长，或者直接陷入死循环，导致页面卡死，后面的任务当然就无法继续执行了。</p><p>但是，在前端的某些任务的确是非常耗时的，比如网络请求、定时器和事件监听等等，如果让他们和别的任务一样都老老实实的排队等待执行的话，执行效率会非常低。所以，这时候浏览器为这些耗时的任务开辟了另外的线程，主要包括<strong>事件触发线程</strong>、<strong>定时器触发线程</strong>和<strong>异步 HTTP 请求线程</strong>。</p><h3 id="浏览器多线程"><a href="#浏览器多线程" class="headerlink" title="浏览器多线程"></a>浏览器多线程</h3><p>浏览器<strong>渲染进程</strong>是多线程的，它包含如下线程：</p><ul><li>GUI 渲染线程</li><li>JS 引擎线程</li><li>事件触发线程</li><li>定时器触发线程</li><li>异步 HTTP 请求线程</li></ul><h4 id="1、GUI-渲染线程"><a href="#1、GUI-渲染线程" class="headerlink" title="1、GUI 渲染线程"></a>1、GUI 渲染线程</h4><p>负责渲染浏览器界面，解析 HTML、CSS，当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行，GUI 渲染线程与 JS 引擎线程是互斥的，因为 JS 可以操作 DOM 元素， 从而影响到 GUI 的渲染结果，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p><h4 id="2、JS-引擎线程"><a href="#2、JS-引擎线程" class="headerlink" title="2、JS 引擎线程"></a>2、JS 引擎线程</h4><p>JS 内核（例如V8引擎），负责处理 Javascript 脚本程序，JS 引擎一直等待着任务队列中任务的到来，然后加以处理，因为 GUI 渲染线程与JS引擎线程是互斥的，所以如果 JS 执行时间过长，页面渲染就不连贯，造成页面渲染加载阻塞。</p><h4 id="3、事件触发线程"><a href="#3、事件触发线程" class="headerlink" title="3、事件触发线程"></a>3、事件触发线程</h4><p>由于 JS 引擎这个单线程的家伙自己都忙不过来，所以需要浏览器另开一个线程协助它，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</p><h4 id="4、定时触发器线程"><a href="#4、定时触发器线程" class="headerlink" title="4、定时触发器线程"></a>4、定时触发器线程</h4><p>setInterval 与 setTimeout所在线程，JS 引擎阻塞状态下计时不准确，所以由浏览器另开线程单独计时，计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行。</p><h4 id="5、异步-HTTP-请求线程"><a href="#5、异步-HTTP-请求线程" class="headerlink" title="5、异步 HTTP 请求线程"></a>5、异步 HTTP 请求线程</h4><p>如果请求有回调事件，异步线程就产生<strong>状态变更事件</strong>，将这个回调再放入事件队列中，等 JS 引擎空闲后执行</p><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>js 一直在做一个工作，就是从任务队列里提取任务，放到主线程里执行，看下面这张图：</p><p><img src="https://gongyz.oss-cn-shenzhen.aliyuncs.com/blog/u8rkfQEHPu7h.png?imageslim" alt="mark"></p><ul><li>JS 运行时引擎(runtime)：也就是 js 线程，由内存堆(heap)和调用栈(stack)组成，其中内存堆是用于内存分配，调用栈是代码执行时的栈</li><li>Web APIs：上文中说到的浏览器为异步任务单独开辟的线程在这里可以统一理解为 Web APIs</li><li>回调队列(callback queue)：也就是任务队列，上面 Web APIs 子线程任务执行结束后会将任务的回调函数推入回调队列</li><li>事件循环(Event Loop)：事件轮询机制，观察运行时调用栈是否为空，如果为空，将回调队列中的任务推到调用栈，回调队列遵循先入先出(FIFO)的原则，也就是按照子线程执行任务完成顺序依次被调用</li></ul><p>我们再来看一个经典的问题，下面代码输出的结果是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>结果是 2、1，因为执行 setTimeout 会立即交给浏览器的定时触发器线程去处理，计时完毕后会把匿名函数放到任务队列里等待 js 主线程调用，但这个时候 js 线程里的 stack 并不是空的，因为还有一句 <code>console.log(2)</code>。要等到 <code>console.log(2)</code>执行完之后，才通过事件循环把匿名函数推到 stack 里面去执行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>js 从诞生起是单线程的，所谓的 js 异步，其实是由单线程的 js、多线程的宿主浏览器和事件循环机制共同作用而成</p><h2 id="二、Javascript-异步编程的演进"><a href="#二、Javascript-异步编程的演进" class="headerlink" title="二、Javascript 异步编程的演进"></a>二、Javascript 异步编程的演进</h2><h3 id="1、回调函数"><a href="#1、回调函数" class="headerlink" title="1、回调函数"></a>1、回调函数</h3><p>实现 js 异步编程最基础方式的就是<strong>回调函数</strong>，这里列举几个大家熟悉的场景，比如：Ajax 请求、IO 操作或者定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//回调函数</span></span><br><span class="line">&#125;);</span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//回调函数</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>如上面代码，回调本身没什么毛病，是比较好用的，但是随着 Web 前端的复杂度不断提高，以及 js 应用场景的不断拓宽，光是回调已经不够用了。</p><p>因为我们阅读和编写程序是顺序的，对于复杂的回调函数会不易理解，所以我们需要一种同步的、顺序的方式来表达异步，看下面栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数实现两数相加，两个数字都是异步获取</span></span><br><span class="line"><span class="comment">// 这里 fetchX() 和 fetchY() 是异步获取数字的 Ajax 请求，接受一个回调函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">getX,  getY, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y</span><br><span class="line">  getX(<span class="function"><span class="keyword">function</span>(<span class="params">xVal</span>) </span>&#123;</span><br><span class="line">    x = xVal</span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  getY(<span class="function"><span class="keyword">function</span>(<span class="params">yVal</span>) </span>&#123;</span><br><span class="line">    y = yVal</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">add(fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再来看下用 Promise 怎么实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise 实现两数相加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里 fetchX()、fetchY()返回相应值的 Promise</span></span><br><span class="line">add(fetchX(), fetchY()).then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里只需保证 fetchX() 和 fetchY() 返回的是 Promise，然后直接用 <code>Promise.all</code> 即可，显然第二种处理起来是不是顺畅得多？</p><h3 id="2、Promise"><a href="#2、Promise" class="headerlink" title="2、Promise"></a>2、Promise</h3><p><code>Promise</code> 是一种弥补回调函数不足的异步解决方案，最早由社区提出并实现，后来写进了 es6 规范，简单地说，<code>Promise</code> 是一个特殊的对象，它可以表示异步操作的成功或者失败，同时返回异步操作的执行结果。</p><h4 id="理解-Promise"><a href="#理解-Promise" class="headerlink" title="理解 Promise"></a>理解 Promise</h4><p>什么意思呢，上面的解释可能还是不够直观，咱们举个栗子：</p><p>假设你苦苦追求的女神，有一天终于禁不住你的死缠烂打，答应跟你去看电影了。那答应跟你去看电影这个事情就是一个<strong>承诺（Promise）</strong>。可其实你心里也没底，你并不知道女神会不会真的陪你去看电影，女神可能兑现承诺，也可能放你鸽子。</p><p>这就是 Promise，一个 Promise 有三种状态：</p><ol><li>Promise 是<strong>待定的（pending）</strong>： 你并不知道女神会不会真的陪你去看电影</li><li>Promise 是<strong>已解决的（resolved）</strong>：女神兑现承诺</li><li>Promise 是<strong>被拒绝的（rejected）</strong>: 被放鸽子</li></ol><h4 id="创建一个-Promise"><a href="#创建一个-Promise" class="headerlink" title="创建一个 Promise"></a>创建一个 Promise</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isHayyp = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> watchingMovies = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isHayyp) &#123;</span><br><span class="line">      <span class="keyword">const</span> movie = &#123;</span><br><span class="line">        name: <span class="string">'海王'</span>,</span><br><span class="line">        time: <span class="string">'2018-12-27 18:20'</span></span><br><span class="line">      &#125;</span><br><span class="line">    resolve(movie)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'女神心情不好'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchingMovies.then(<span class="function">(<span class="params">movie</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 女神兑现承诺，一起去看了电影</span></span><br><span class="line">    <span class="comment">// 然后再一起去吃饭</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 女神心情不好，被放鸽子了，回家打游戏</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上两段代码，第一段是调用 <code>Promise</code> 构造函数，第二段是调用了 <code>Promise</code> 实例的 <code>.then</code> 方法</p><ol><li>构造函数<ul><li>构造函数接受一个函数作为参数</li><li>调用构造函数得到实例 watchingMovies 的同时，作为参数的函数会立即执行</li><li>参数函数接受两个回调函数参数 resolve 和 reject</li><li>在参数函数被执行的过程中，如果在其内部调用 resolve，会将 watchingMovies 的状态变成 fulfilled，或者调用 reject，会将 watchingMovies 的状态变成 rejected</li></ul></li><li>调用 <code>.then</code><ul><li>调用 <code>.then</code> 可以为实例 p 注册两种状态回调函数</li><li>当实例 watchingMovies 的状态为 fulfilled，会触发第一个函数执行</li><li>当实例 watchingMovies 的状态为 rejected，则触发第二个函数执行</li></ul></li></ol><p>我们结合上面讲的 js 异步，再来看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>打印结果是 132，<code>Promise</code> 新建后立即执行，所以首先输出的是 1。然后，<code>then</code> 方法注册的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 2 最后输出。</p><h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><p>Promise 的 API 分为构造函数、实例方法和静态方法</p><ul><li>1个构造函数： <code>new Promise</code></li><li>3个实例方法：<code>.then</code> 、 <code>.catch</code> 和 <code>.finally</code></li><li>4个静态方法：<code>Promise.all</code>、<code>Promise.race</code>、<code>Promise.resolve</code> 和 <code>Promise.reject</code></li></ul><h5 id="1、-then方法"><a href="#1、-then方法" class="headerlink" title="1、.then方法"></a>1、<code>.then</code>方法</h5><p><code>.then</code>方法返回的是一个新的 <code>Promise</code> 实例（注意，不是原来那个 <code>Promise</code> 实例）。因此可以采用链式写法，即 <code>.then</code> 方法后面再调用另一个 <code>.then</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码使用 <code>.then</code> 方法，依次注册了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数</p><h5 id="2、-catch方法"><a href="#2、-catch方法" class="headerlink" title="2、.catch方法"></a>2、<code>.catch</code>方法</h5><p>处理异常的推荐写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为 catch 可以捕获到 then 里的异常，Promise 对象的错误具有『冒泡』性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 <code>catch</code> 捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由 <code>getJSON</code> 产生，两个由 <code>then</code> 产生。它们之中任何一个抛出的错误，都会被最后一个 <code>catch</code> 捕获。</p><h5 id="3、Promise-all方法"><a href="#3、Promise-all方法" class="headerlink" title="3、Promise.all方法"></a>3、<code>Promise.all</code>方法</h5><p><code>Promise.all</code> 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all</code> 方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code> 都是 Promise 实例，如果不是，就会先调用 <code>Promise.resolve</code> 方法，将参数转为 Promise 实例<code>p</code> 的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况：</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个 Promise 对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promiseList = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promiseList</code> 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 <code>fulfilled</code>，或者其中有一个变为 <code>rejected</code>，才会调用 <code>Promise.all</code> 方法后面的回调函数。</p><h5 id="4、Promise-race方法"><a href="#4、Promise-race方法" class="headerlink" title="4、Promise.race方法"></a>4、<code>Promise.race</code>方法</h5><p><code>Promise.race</code> 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br></pre></td></tr></table></figure><p>但不同的是，这里只要 <code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 <code>p</code> 的回调函数。</p><h5 id="5、Promise-resolve-和-Promise-reject方法"><a href="#5、Promise-resolve-和-Promise-reject方法" class="headerlink" title="5、Promise.resolve 和 Promise.reject方法"></a>5、<code>Promise.resolve</code> 和 <code>Promise.reject</code>方法</h5><p><code>Promise.resolve</code> 会返回一个状态为 fulfilled 状态的 Promise 对象，<code>Promise.reject</code> 与 <code>Promise.resolve</code> 同理，区别在于返回的 Promise 对象状态为 rejected。</p><p><code>Promise.resolve</code> 等价于下面的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><h4 id="Promise-和-setTimeout-的执行顺序"><a href="#Promise-和-setTimeout-的执行顺序" class="headerlink" title="Promise 和 setTimeout 的执行顺序"></a>Promise 和 setTimeout 的执行顺序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>以上代码运行结果是 2431，为什么不是 2413，不是 setTimeout 先加入任务队列的么？</p><p>所以这里又要从任务队列说起了，任务队列可以细分为 <strong>MacroTask Queue(宏任务队列)</strong> 和 <strong>MicroTask Queue(微任务队列)</strong> 两种</p><p>整个 script 代码放在了宏任务队列，setTimeout 也放在了宏任务队列，但 <code>promise.then</code> 放到了微任务队列</p><p>这两个队列的执行顺序如下：</p><ol><li>取宏任务队列里第一个 task，执行之</li><li>把微任务队列里<strong>所有</strong> task 执行完</li><li>再取宏任务队列里下一个 task 执行之，周而复始</li></ol><p>代码开始执行时，所有这些代码在宏任务队列中，取出来执行之。</p><p>后面遇到了setTimeout，又加入到macrotask queue中，</p><p>然后，遇到了 <code>promise.then</code>，<strong>放入到了另一个队列，微任务队列</strong>。</p><p>等整个 stack 执行完后，</p><p>下一步该取的是<strong>微任务队列</strong>中的任务了。</p><p>因此 <code>promise.then</code> 的回调比 setTimeout 先执行</p><h3 id="3、Generator-函数（生成器函数）"><a href="#3、Generator-函数（生成器函数）" class="headerlink" title="3、Generator 函数（生成器函数）"></a>3、Generator 函数（生成器函数）</h3><p>Generator 函数，也可以叫生成器函数，是 ES6 提供的一种异步编程解决方案，执行生成器函数会返回一个迭代器对象，所以我们先来看下什么是迭代器。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器并不是某一个语法或者对象，而是一个协议，只要遵循了这个协议，所实现的都是迭代器对象，下面我们来看一个简易的迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 返回迭代器对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// next() 方法返回的结果对象</span></span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个迭代器生成函数，作用就是返回一个迭代器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的迭代器对象<code>it</code></p><p>迭代器对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code></p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束</p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>借助于迭代器的这个特征，我们现在可以理解一下生成器，字面意思呢，就是生成一个东西，那生成器函数就是一个返回迭代器的函数</p><p>生成器函数从语法上来看，只是<code>function</code>关键字与函数名之间比普通函数多了一个星号，同时每一次迭代，都会通过 <code>yield</code>关键字来实现</p><p>我们把上面代码改写一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> array[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>打印的值和上面代码是一模一样的，所以生成器的出现实际上是为了简化掉我们上面那一坨代码，简化创建迭代器的过程</p><p>咱们再来看个简单的栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br></pre></td></tr></table></figure><p>上面代码定义了一个生成器函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p></p><p>下一步，我们必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。我们可以理解为，生成器函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行</p><h4 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h4><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co 模块</a>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于生成器函数的自动执行</p><p>下面是一个生成器函数，用于依次读取两个文件，这里的 <code>yield</code> 关键字后面跟的是一个 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>)</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>co 模块可以让你不用编写 Generator 函数的执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line">co(gen)</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示</p><p>为什么 co 可以自动执行 Generator 函数？简单的说就是将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权，具体细节大家可以去看 co 库的源码。</p><h3 id="4、Async-await"><a href="#4、Async-await" class="headerlink" title="4、Async/await"></a>4、Async/await</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便</p><p><code>async/await</code>调用方式跟使用<code>co</code>库后的<code>Generator</code>函数看起来很相似，自带执行器，并且语义更清楚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>)</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen)</span><br></pre></td></tr></table></figure><p>写成 async 函数，就是下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>)</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>所以说，生成器函数和 co 库都只是 async/await 标准化落地之前的过度方案，现在我们只要掌握 Promise 和 async/await 即可。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>然后最后总结一下，今天我们探讨了 js 异步的实现以及 js 异步流程的演进路线，js 异步的实现，相信大家现在都能理解了，而 js 异步流程，从 promise 到 async 函数，无论如何，promise都是基石，是必须要掌握的，而生成器函数和 co 只是为了引出 async/await 的过度方案，所以大家只要掌握 promise 和 最终方案 async/await 即可。</p></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/10/06/Node、NPM安装/" class="pre">Node、NPM安装</a><a href="/2018/08/27/ECMAScript 6/" class="next">ECMAScript 6</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg4NC8xMDQzNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Javascript-异步的由来"><span class="toc-text">一、Javascript 异步的由来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript-单线程"><span class="toc-text">Javascript 单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器多线程"><span class="toc-text">浏览器多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、GUI-渲染线程"><span class="toc-text">1、GUI 渲染线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、JS-引擎线程"><span class="toc-text">2、JS 引擎线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、事件触发线程"><span class="toc-text">3、事件触发线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、定时触发器线程"><span class="toc-text">4、定时触发器线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、异步-HTTP-请求线程"><span class="toc-text">5、异步 HTTP 请求线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件循环（Event-Loop）"><span class="toc-text">事件循环（Event Loop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Javascript-异步编程的演进"><span class="toc-text">二、Javascript 异步编程的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、回调函数"><span class="toc-text">1、回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Promise"><span class="toc-text">2、Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理解-Promise"><span class="toc-text">理解 Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个-Promise"><span class="toc-text">创建一个 Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-API"><span class="toc-text">Promise API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、-then方法"><span class="toc-text">1、.then方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、-catch方法"><span class="toc-text">2、.catch方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、Promise-all方法"><span class="toc-text">3、Promise.all方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、Promise-race方法"><span class="toc-text">4、Promise.race方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、Promise-resolve-和-Promise-reject方法"><span class="toc-text">5、Promise.resolve 和 Promise.reject方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-和-setTimeout-的执行顺序"><span class="toc-text">Promise 和 setTimeout 的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、Generator-函数（生成器函数）"><span class="toc-text">3、Generator 函数（生成器函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器"><span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-模块"><span class="toc-text">co 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、Async-await"><span class="toc-text">4、Async/await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、总结"><span class="toc-text">三、总结</span></a></li></ol></div><div class="widget"><div class="widget-title"> <i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/09/Express框架入门/">Express框架入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/11/Connect框架源码分析/">Connect框架源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/Node基础知识/">Node基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Node、NPM安装/">Node、NPM安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/09/Javascript异步编程的演进/">Javascript异步编程的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/ECMAScript 6/">ECMAScript 6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/12/Redux入门指南/">Redux入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/跨文档消息通信/">跨文档消息通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/事件探究/">事件探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/16/Blob API的使用/">Blob API的使用</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-gui">分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Express/">Express</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React-Native</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size:15px">JavaScript</a> <a href="/tags/React-Native/" style="font-size:15px">React-Native</a> <a href="/tags/服务器/" style="font-size:15px">服务器</a> <a href="/tags/Express/" style="font-size:15px">Express</a> <a href="/tags/Linux/" style="font-size:15px">Linux</a> <a href="/tags/Node/" style="font-size:15px">Node</a> <a href="/tags/React/" style="font-size:15px">React</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/Web安全/" style="font-size:15px">Web安全</a></div></div><div class="widget"><div class="widget-title"> <i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-you">友情链接</i></div><ul><li><a href="https://github.com/GYunZhi" title="GitHub" target="_blank">GitHub</a></li><li><a href="https://gitee.com/gongyz" title="Gitee" target="_blank">Gitee</a></li><li><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/README.md" title="BlueLake" target="_blank">BlueLake</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/jquery.min.js"></script><script type="text/javascript" src="/js/love.js" charset="utf-8"></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> | <a href="/atom.xml">订阅</a> | <a href="/about/">关于</a></p><p>Hi.第<i id="busuanzi_container_site_pv"></i><i id="busuanzi_value_site_pv"></i>个小伙伴</p><p class="statistics"></p><span id="since"></span><span class="myface">(●'◡'●)ﾉ♥</span><p></p><p></p><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("02/15/2018 10:30:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=Math.floor(e_hrsold),e_minsold=60*(e_hrsold-hrsold),minsold=Math.floor(60*(e_hrsold-hrsold)),seconds=Math.floor(60*(e_minsold-minsold)),since.innerHTML="博客已萌萌哒运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}show_date_time()</script><p> <span>Copyright &copy;<a href="/." rel="nofollow">GYunZhi.</a></span> <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake.</a></span> <span>Count by <a href="http://busuanzi.ibruce.info/">busuanzi.</a></span> <span>Powered by</span> <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?814d72806e475b8704164a120fe75726";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>!function(e,t){var c,n=e.getElementsByTagName("body")[0];"function"!=typeof LivereTower&&((c=e.createElement("script")).src="https://cdn-city.livere.com/js/embed.dist.js",c.async=!0,n.appendChild(c))}(document)</script></body></html>