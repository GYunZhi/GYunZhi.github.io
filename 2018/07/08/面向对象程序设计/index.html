<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学会学习的人，是幸福的人"><title>面向对象程序设计 | Hi, MrGong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面向对象程序设计</h1><a id="logo" href="/.">Hi, MrGong</a><p class="description"></p></div><div id="nav-menu"> <a href="/." class="current"><i class="fa fa-home">首页</i></a> <a href="/archives/"><i class="fa fa-archive">归档</i></a> <a href="/about/"><i class="fa fa-user">关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">面向对象程序设计</h1><div class="post-meta"><a href="/2018/07/08/面向对象程序设计/#comments" class="comment-count"></a><p><span class="date">Jul 08, 2018</span><span><a href="/categories/JavaScript/" class="category">JavaScript</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在学习面向对象开发之前，我觉的有必要先来了解对象这个东西是什么，ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员自定义的类型。</p><p>原生的引用类型有：Object、Array、Date、RegExp、Function，基本包装类型Boolean、Number、String以及两个单体内置对象Global（在浏览器环境window对象就是Global）、Math。</p><p>说明：Object、Array、…、String、Global、Math都是内置对象，ECMA-262对内置对象的定义是：“由ECMAScript提供的，不依赖于宿主环境的对象，这些对象在ECMAScript执行之前就已经存在了”，也就是说开发人员不需要显式的实例化内置对象，因为它们已经实例化了。那么单体内置对象又是什么意思呢。其实也很好理解，看一下下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在chromo控制台操作</span></span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line">ƒ <span class="built_in">Object</span>() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span></span><br><span class="line">ƒ <span class="built_in">Array</span>() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span></span><br><span class="line"><span class="built_in">Math</span> &#123;<span class="attr">abs</span>: ƒ, <span class="attr">acos</span>: ƒ, <span class="attr">acosh</span>: ƒ, <span class="attr">asin</span>: ƒ, <span class="attr">asinh</span>: ƒ, …&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Object、Array是函数，而Math是对象，所以可以直接使用Math的API，而其他的内置对象一般是作为构造函数，通过new关键字用来来创建一个对象的。</p><p>创建自定义对象最简单的方式就是创建一个Object实例，Object是所有对象的基础，也就是说Object类型所具有的属性和方法同样也存在于具体的对象中。（<em>在后面的讲解原型链会做出具体说明</em>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name=<span class="string">'leo'</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'名字:'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">person.sayName() <span class="comment">// leo</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们创建了一个person对象，并且给它添加了name属性和sayName方法，但现在有更简洁的写法，通过对象字面量形式来创建对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'leo'</span>,</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();</span><br></pre></td></tr></table></figure><h4 id="对象的属性类型"><a href="#对象的属性类型" class="headerlink" title="对象的属性类型"></a>对象的属性类型</h4><p>ECMAScript-262 的定义中，对象的属性有两种，一种是数据属性，另一种是访问器属性 ，这两种属性都有一些特性值来描述该属性。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。而且为了表示这些特性是内部值，该规范把它们放在了两对方括号中，例如[[Enumerable]]。</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>数据属性共有4个描述其行为的特性，其中包含一个存放数据值得特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[Configurable]]： 表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true。</span><br><span class="line"></span><br><span class="line">[[Enumerable]]： 表示能否通过for-in遍历属性。默认为true。</span><br><span class="line"></span><br><span class="line">[[Writable]]： 表示能否修改属性的值。默认为true。</span><br><span class="line"></span><br><span class="line">[[Value]]： 用于存放属性的数据值，默认为undefined。</span><br></pre></td></tr></table></figure><p><strong>要修改属性默认的特性，必须使用 ESMAScript 5 的<code>Object.defineProperty()</code>方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'gongyz'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'zhangsan'</span></span><br><span class="line">&#125;)</span><br><span class="line">person.name = <span class="string">'123'</span></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// 'zhangsan'</span></span><br></pre></td></tr></table></figure><p>上面的代码创建了一个name属性，当我们调用<code>Object.defineProperty()</code>writable特性设为false后，如果为它指定新值，非严格模式下操作会被忽略，严格模式下，赋值操作将会抛出错误。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性不包括数据值，但它包含一对getter和setter函数（不过这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责处理数据。访问器属性有如下4个特性。</p><pre><code>[[Configurable]]：同上。
[[Enumerable]]：同上。
[[Get]]：在读取属性时调用的函数。默认为undefined。
[[Set]]：在写入属性时调用的函数。默认为undefined。
</code></pre><p><strong>注意：访问器属性不能被直接定义，必须使用<code>Object.defineProperty()</code>方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问器属性</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>, <span class="comment">// _year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性</span></span><br><span class="line">  version: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newVal</span><br><span class="line">      <span class="keyword">this</span>.version += newVal - <span class="number">2004</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2008</span></span><br><span class="line"><span class="built_in">console</span>.log(book)</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个book对象，并给它定义了两个默认属性；<code>_year</code>和<code>version</code>。<code>_year</code>前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year包含一个getter和setter函数。getter函数返回<code>_year</code>的值，setter函数通过计算来确定正确的版本。因此把year属性修改为2008会导致<code>_year</code>变成2008，而<code>version</code>变成5。这是访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p><p>注意：在IE8及之前的IE浏览器不支持<code>Object.defineProperty()</code>方法，要创建访问器属性，一般使用两个非标准的方法<code>__defineGetter__</code> 和<code>__defineSetter__</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义访问器属性的旧方法</span><br><span class="line">book.__defineGetter__(&apos;year&apos;, function () &#123;</span><br><span class="line">  return this._year</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.__defineSetter__(&apos;year&apos;, function (newVal) &#123;</span><br><span class="line">  if (newVal &gt; 2004) &#123;</span><br><span class="line">    this._year = newVal</span><br><span class="line">    this.version += newVal - 2004</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h5><p>ESMAScript 5 定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次性定义多个属性。这个方法接收两个对象参数：第一个是要添加和修改其属性的对象，第二个对象的属性与第一个对象要添加或修改的属性一 一对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  version: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newVal</span><br><span class="line">        <span class="keyword">this</span>.version += newVal - <span class="number">2004</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2008</span></span><br><span class="line"><span class="built_in">console</span>.log(book)</span><br><span class="line"><span class="built_in">console</span>.log(book.year)</span><br></pre></td></tr></table></figure><h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><p>ESMAScript 5 的<code>Object.getOwnPropertyDescriptor()</code> 方法，可以获取给定属性的特性。同样的IE9+的浏览器支持此方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建多个对象，会产生大量重复代码。为了解决这个问题，同时考虑到在ECMAScript中无法创建类，开发人员就用封装函数来创建对象。这种通过用函数封装以特定接口创建对象的细节，并通过调用函数来创建对象的方式，称为<em>工厂模式</em>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//原料</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加工</span></span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.sex = sex;</span><br><span class="line"></span><br><span class="line">  obj.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'名字:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  obj.showSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'性别:'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出厂</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'leo'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'gongyz'</span>, <span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line">p1.showName(); <span class="comment">// leo</span></span><br><span class="line">p2.showName(); <span class="comment">// gongyz</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.showName === p2.showName) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>函数createPerson()能够根据接收的参数来创建一个包含基本信息的person对象。可以多次调用这个函数，而每次它都会返回一个包含两个属性和两个方法的对象。<strong>工厂模式虽然解决了创建多个相似对象的问题，但是却没有解决对象识别问题（没有办法通过 instance 判断创建出来的对象是什么类型，因为它总是Object）</strong>，随着JavaScript的发展，有一个新的模式出现了。</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>我们知道，像Object、Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而创建自定义对象类型的属性和方法。例如，我们可以使用构造函数模式将前面的例子重写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假想的系统内部的工作流程</span></span><br><span class="line">  <span class="comment">// var this=new Object();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'名字:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.showSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'性别:'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假想的系统内部的工作流程</span></span><br><span class="line">  <span class="comment">// return this;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'leo'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'lili'</span>, <span class="string">'female'</span>);</span><br><span class="line"></span><br><span class="line">p1.showName(); <span class="comment">// leo</span></span><br><span class="line">p2.showName(); <span class="comment">// lili</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，Person()函数取代了createPerson()函数，同时Person()中的代码与createPerson()还存在一下不同之处：</p><ul><li>没有显示的创建对象</li><li>直接将属性和方法赋给了this对象</li><li>没有return语句</li><li>首字母大写（按照惯例，构造函数首字母应该大写）</li><li>使用new关键字调用构造函数来创建对象</li></ul><p>其实，要创建Person的新实例，必须使用new操作符。使用new关键字调用构造函数时实际上会经历下面4个步骤：</p><ul><li>创建一个新的对象</li><li>this指向这个新的对象</li><li>执行构造函数中的代码，为对象添加属性和方法</li><li>返回新对象</li></ul><p>使用构造函数创建对象可以将它的实例标识为一种特定的类型，这样就解决了工厂模式中对象识别问题。上面代码中创建的对象p1、p2都是Person的实例，但同时也都是Object的实例，这是因为所有的对象都继承自Object（这个在后面的继承中会说明）。</p><p><strong>1、将构造函数当做函数</strong></p><p>构造函数与普通函数的唯一区别就在于调用它们的方式不同。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；如果不通过 new 操作符调用，那它就和普通的函数调用没什么区别。例如前面定义的Person函数可以通过下列的任何一种方式调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当做构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'gongyz'</span>, <span class="string">'male'</span>)</span><br><span class="line">person.showName() <span class="comment">// gongyz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当做普通函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = Person(<span class="string">'gongyz'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="built_in">window</span>.showName() <span class="comment">// gongyz // 添加到window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Person.call(obj,<span class="string">'gongyz'</span>, <span class="string">'male'</span>)</span><br><span class="line">obj.showName() <span class="comment">// gongyz</span></span><br></pre></td></tr></table></figure><p><strong>2、构造函数的问题</strong></p><p>构造函数模式使用了new关键字，解决了对象识别问题，但是没有解决方法复用问题，每次创建一个实例的时候，方法就会在那个实例上重新创建一遍，好在，这个问题可以通过原型模式解决。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>几乎所有的函数（除了一些内建函数）都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是用来存放所有实例共享的属性和方法。我们把这个对象称为<strong>原型对象</strong>。我们可以给内置对象的prototype添加属性和方法，但是不推荐这样做，这样可能会覆盖掉内置对象的属性或方法。拿上面的例子来说，我们可以把方法和属性都放到原型对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'gongyz'</span>;</span><br><span class="line">Person.prototype.sex = <span class="string">'male'</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'名字:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.showSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'性别:'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.showName(); <span class="comment">// gonygz</span></span><br><span class="line"></span><br><span class="line">p2.showName(); <span class="comment">// gongyz</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.showName == p2.showName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h4><p>通常情况下，公用的属性和方法才会放在prototype上，所以我们一般使用构造模式 + 原型模式的混合方式来创建对象 ，这样每一个实例既可以有自己的属性和方法，同时也有了共有的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'名字:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.showSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'性别:'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'leo'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'lili'</span>, <span class="string">'female'</span>);</span><br><span class="line"></span><br><span class="line">p1.showName();</span><br><span class="line">p1.showSex();</span><br><span class="line"></span><br><span class="line">p2.showName();</span><br><span class="line">p2.showSex();</span><br></pre></td></tr></table></figure><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><p>在JavaScript，this的指向是很多该开始接触这门语言的人比较头疼的问题，大部分情况下，函数的调用方式决定了this的值，但也有一些例外的情况，同时在严格模式和非严格模式下this的值也会有一些差别。</p><p>通常情况下：</p><ol><li>函数通过 new 调用，this 绑定的是新创建的对象</li><li>函数在某个上下文对象中调用，this 绑定的是那个上下文对象</li><li>函数通过call、apply、bind调用，this 绑定的是指定的上下文对象</li><li>全局环境下调用，默认绑定的是window对象。如果在严格模式下，绑定到undefined。</li></ol><p>this指向出问题的情况：</p><ol><li>构造函数里面有定时器</li><li>构造函数里面有事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数里面有定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.n = <span class="number">12</span></span><br><span class="line">	<span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">	setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		_this.show()</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">	&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数里面有事件</span></span><br><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.n = <span class="number">12</span></span><br><span class="line">	<span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">	oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">		_this.show()</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// input</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><p>上面两种情况下，this指向的分别是window和input对象，解决这个问题很简单，另外保存一份当前对象的this引用就可以了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是复用代码的一种形式，子类通过继承父类的属性和方法达到代码复用的目的。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在每个<strong>对象</strong>上面都有一个<code>__proto__</code>属性，可称为隐式原型 。这不是一个标准的属性，但是每个浏览器都支持。该隐式原型指向的是创建该对象的构造函数的原型对象。这样就保证了实例能够访问在构造函数的原型中定义的属性和方法。对象和原型对象之间通过<code>__proto__</code>就构成了一条原型链。原型链的最外层是<code>Object.prototype</code> ，因为Object是所有对象的基础。</p><h4 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h4><p>父类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.showSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name, sex, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父级的构造函数继承属性		</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, sex); <span class="comment">// this -&gt; new 出来的Worker对象  </span></span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Worker.prototype = Person.prototype // 直接把父类的引用给子类，会导致子类修改父类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过原型来继承父级的方法	</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> Person.prototype) &#123;</span><br><span class="line">  	Worker.prototype[i] = Person.prototype[i];</span><br><span class="line">  &#125;</span><br><span class="line">  Worker.prototype.showJob = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.job);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在子类的构造函数中调用父类的构造函数，并且通过call方法修改this指向，可以继承父类的属性。接下来我们需要继承父类的方法，如果直接把父类构造函数的原型对象引用赋值给子类原型对象，可以实现继承父类的方法，但是这样会导致我们在修改子类原型对象的时候会影响到父类的原型对象，所以我们通过for-in来继承父类的方法。可以封装一个extend方法来进行拷贝操作。下面是一个简单的extend方法封装。感兴趣可以去看看JQuery中的extend方法。实现起来更加复杂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj1, obj2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj2)&#123;</span><br><span class="line">		obj1[attr] = obj2[attr]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝方法有一个很大的问题就是，如果父类中存在不可枚举的方法，那么通过for-in是无法继承的。</p><h4 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h4><p>在JavaScript中其实没有类的概念的，类式继承是通过构造函数实现继承。</p><p>子类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name, sex, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父级的构造函数继承属性		</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, sex); <span class="comment">// this -&gt; new 出来的Worker对象  </span></span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父级原型中的方法</span></span><br><span class="line">Worker.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Worker.prototype.constructor = Worker; <span class="comment">// 让constructor 指向 Worker</span></span><br><span class="line">Worker.prototype.showJob = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象中常用的属性和方法"><a href="#对象中常用的属性和方法" class="headerlink" title="对象中常用的属性和方法"></a>对象中常用的属性和方法</h3><p>hasOwnProperty : 判断是否是对象自身下面的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr.num = <span class="number">10</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.num2 = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log( arr.hasOwnProperty(<span class="string">'num'</span>)  ) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(  arr.hasOwnProperty(<span class="string">'num2'</span>)  )  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>constructor : 查看对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log( a1.constructor )  <span class="comment">// Person</span></span><br><span class="line">Person.prototype.constructor = Person  <span class="comment">// 每一个函数都会有的，都是自动生成的</span></span><br></pre></td></tr></table></figure><p>instanceof : 对象与构造函数在原型链上是否有关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log( person <span class="keyword">instanceof</span> <span class="built_in">Object</span> )  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/07/15/从HTML5拖放事件探究文件上传功能/" class="pre">从HTML5拖放事件探究文件上传功能</a><a href="/2018/07/01/Ajax基础和应用/" class="next">Ajax基础和应用</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg4NC8xMDQzNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解对象"><span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的属性类型"><span class="toc-text">对象的属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据属性"><span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#访问器属性"><span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定义多个属性"><span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读取属性的特性"><span class="toc-text">读取属性的特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象"><span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数模式"><span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合使用构造函数和原型模式"><span class="toc-text">组合使用构造函数和原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this指向问题"><span class="toc-text">this指向问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拷贝继承"><span class="toc-text">拷贝继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类式继承"><span class="toc-text">类式继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象中常用的属性和方法"><span class="toc-text">对象中常用的属性和方法</span></a></li></ol></div><div class="widget"><div class="widget-title"> <i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/09/Express框架入门/">Express框架入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/11/Connect框架源码分析/">Connect框架源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/Node基础知识/">Node基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Node、NPM安装/">Node、NPM安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/09/Javascript异步编程的演进/">Javascript异步编程的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/ECMAScript 6/">ECMAScript 6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/12/Redux入门指南/">Redux入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/跨文档消息通信/">跨文档消息通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/事件探究/">事件探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/16/Blob API的使用/">Blob API的使用</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-gui">分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Express/">Express</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React-Native</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web安全/">Web安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size:15px">JavaScript</a> <a href="/tags/React-Native/" style="font-size:15px">React-Native</a> <a href="/tags/服务器/" style="font-size:15px">服务器</a> <a href="/tags/Express/" style="font-size:15px">Express</a> <a href="/tags/Linux/" style="font-size:15px">Linux</a> <a href="/tags/Node/" style="font-size:15px">Node</a> <a href="/tags/React/" style="font-size:15px">React</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/Web安全/" style="font-size:15px">Web安全</a></div></div><div class="widget"><div class="widget-title"> <i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-you">友情链接</i></div><ul><li><a href="https://github.com/GYunZhi" title="GitHub" target="_blank">GitHub</a></li><li><a href="https://gitee.com/gongyz" title="Gitee" target="_blank">Gitee</a></li><li><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/README.md" title="BlueLake" target="_blank">BlueLake</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/jquery.min.js"></script><script type="text/javascript" src="/js/love.js" charset="utf-8"></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> | <a href="/atom.xml">订阅</a> | <a href="/about/">关于</a></p><p>Hi.第<i id="busuanzi_container_site_pv"></i><i id="busuanzi_value_site_pv"></i>个小伙伴</p><p class="statistics"></p><span id="since"></span><span class="myface">(●'◡'●)ﾉ♥</span><p></p><p></p><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("02/15/2018 10:30:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=Math.floor(e_hrsold),e_minsold=60*(e_hrsold-hrsold),minsold=Math.floor(60*(e_hrsold-hrsold)),seconds=Math.floor(60*(e_minsold-minsold)),since.innerHTML="博客已萌萌哒运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}show_date_time()</script><p> <span>Copyright &copy;<a href="/." rel="nofollow">GYunZhi.</a></span> <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake.</a></span> <span>Count by <a href="http://busuanzi.ibruce.info/">busuanzi.</a></span> <span>Powered by</span> <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?814d72806e475b8704164a120fe75726";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>!function(e,t){var c,n=e.getElementsByTagName("body")[0];"function"!=typeof LivereTower&&((c=e.createElement("script")).src="https://cdn-city.livere.com/js/embed.dist.js",c.async=!0,n.appendChild(c))}(document)</script></body></html>